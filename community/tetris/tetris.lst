; Pass 1...

; 0 errors detected in pass 1

; Pass 2...
; 1                       ; Tetris implementation
; 2                       ; Ryan Crosby 2022
; 3                       ;
; 4                       ; Run from 0x01.
; 5                       ;
; 6                       ; Completed:
; 7                       ;
; 8                       ; * Gameboard format
; 9                       ; * Gameboard rendering to console
; 10                      ; * Line clearing
; 11                      ;
; 12                      ; ~120 instructions left to implement the rest of TODO.
; 13                      ;
; 14                      ; TODO:
; 15                      ;
; 16                      ;
; 17                      ; * Description with controls etc.
; 18                      ; * Smarter temporary variable management.
; 19                      ;       Define a small section of memory to use like a shared register pool.
; 20                      ;       Go through the subroutines and replace dedicated temporary variables with shared variables from the register pool that haven't been used yet in the execution flow.
; 21                      ;       Also inline most subroutines, most are called from a single spot.
; 22                      
; 23                      ;
; 24                      
; 25                      ; Constants
; 26                      ;
; 27                      
; 28                      ; Gameboard parameters
; 29                      ; These constants are used for convenience. Changing the value won't change the actual sizes of the gameboards, code will need to be modified as well.
; 30      0000_0000       GAMEBOARD_STRIDE	equ	2	; How many bytes high is the gameboard. 2 bytes = 16 rows.
; 31      0000_0000       GAMEBOARD_COLS	equ	10	; How many columns wide is the gameboard. This is generic enough that it can be adjusted without altering any code.
; 32      0000_0000       GAMEBOARD_SIZE	equ	(GAMEBOARD_STRIDE*GAMEBOARD_COLS)	; Gameboard total size = stride * columns
; 33                      
; 34      0000_0000       PIECE_STAGE_SIZE	equ	(GAMEBOARD_STRIDE*4)	; The piece stage is the same height as the gameboard, but only 4 wide.
; 35                      
; 36      0000_0000       SPACE_CHAR	equ	0x20	; Space
; 37      0000_0000       BLOCK_CHAR	equ	0x23	; #
; 38      0000_0000       EMPTY_CHAR	equ	0x7E 	; ~
; 39      0000_0000       BAR_CHAR	equ	0x7C	; |
; 40                      
; 41      0000_0000       CR_CHAR	equ	0x0D	; Carriage Return CR \r
; 42      0000_0000       LF_CHAR	equ	0x0A	; Linefeed LF \n
; 43                      
; 44                      ; Number constants
; 45      0000_0000       ZERO_CHAR	equ	0x30	; 0
; 46                      
; 47                      ; Alphabet constants
; 48      0000_0000       A_CHAR	equ	0x41	; A
; 49      0000_0000       B_CHAR	equ	A_CHAR+1
; 50      0000_0000       C_CHAR	equ	A_CHAR+2
; 51      0000_0000       D_CHAR	equ	A_CHAR+3
; 52      0000_0000       E_CHAR	equ	A_CHAR+4
; 53      0000_0000       F_CHAR	equ	A_CHAR+5
; 54      0000_0000       G_CHAR	equ	A_CHAR+6
; 55      0000_0000       H_CHAR	equ	A_CHAR+7
; 56      0000_0000       I_CHAR	equ	A_CHAR+8
; 57      0000_0000       J_CHAR	equ	A_CHAR+9
; 58      0000_0000       K_CHAR	equ	A_CHAR+10
; 59      0000_0000       L_CHAR	equ	A_CHAR+11
; 60      0000_0000       M_CHAR	equ	A_CHAR+12
; 61      0000_0000       N_CHAR	equ	A_CHAR+13
; 62      0000_0000       O_CHAR	equ	A_CHAR+14
; 63      0000_0000       P_CHAR	equ	A_CHAR+15
; 64      0000_0000       Q_CHAR	equ	A_CHAR+16
; 65      0000_0000       R_CHAR	equ	A_CHAR+17
; 66      0000_0000       S_CHAR	equ	A_CHAR+18
; 67      0000_0000       T_CHAR	equ	A_CHAR+19
; 68      0000_0000       U_CHAR	equ	A_CHAR+20
; 69      0000_0000       V_CHAR	equ	A_CHAR+21
; 70      0000_0000       W_CHAR	equ	A_CHAR+22
; 71      0000_0000       X_CHAR	equ	A_CHAR+23
; 72      0000_0000       Y_CHAR	equ	A_CHAR+24
; 73      0000_0000       Z_CHAR	equ	A_CHAR+25
; 74                      
; 75                      ; Additional custom instructions
; 76                      ; To use these, call them like: insn INCTO_INSN aa, bb
; 77      0000_0000       IMADD_INSN	equ	0xC0800000	; aa + [bb] --> [aa]. Immediate version of ADD. If aa is 0, allows single instruction LOAD of [bb] to [0].
; 78      0000_0000       AND_INSN	equ	0x81800000	; The WRA version of andto. ANDs [aa] and [bb], and stores in [aa].
; 79      0000_0000       CLRA_INSN	equ	0x81000000	; Stores 0 --> [aa]. Implemented as [aa] & 0 --> [aa].
; 80      0000_0000       INCTO_INSN	equ	0x08200000	; Stores [aa] + 1 --> [bb] in one instruction.
; 81      0000_0000       ALTB_TOC_INSN	equ	0x00C00000	; Stores [aa] < [bb] --> Carry.
; 82      0000_0000       ALEB_TOC_INSN	equ	0x00E00000	; Stores [aa] <= [bb] --> Carry.
; 83      0000_0000       ST_JMP_INSN	equ	0x08080000	; Stores [aa] --> [bb] and jumps to bb.
; 84      0000_0000       OUTC_JMP_INSN	equ	0x98080000	; Writes [aa] to the console and jumps to bb. WRA and WRB are set to make OUT write to console.
; 85      0000_0000       LSR_JCC_INSN	equ	0x820A0000	; Rotates [aa] right, writes the result back to [aa], and jumps if the shifted out bit (carry output) was clear.
; 86                      
; 87                      ; Catch for any jumps to null (0x00). This usually indicates a subroutine hasn't had its return address set.
; 88                      ;
; 89                      ; Also used as a temporary storage register, and sometimes as the return value for subroutines that only need to return a status.
; 90                      
; 91      00              	org	0x00
; 92      00 c810_ff00    tmp	halt
; 93                      
; 94                      ; ENTRY POINT
; 95      01              	org	0x01
; 96      01 4018_ff04    exec	jmp	run	; Jump to start of program
; 97                      
; 98                      
; 99                      ; Pieces templates
; 100                     ;
; 101                     ; Piece patterns are stored as a single byte.
; 102                     ; The 4 lsb bits represent the left of the piece, the 4 msb bits representing the right of the piece.
; 103                     ; The alignment and bit direction matches the piece stage.
; 104                     ;
; 105                     ; A "flipped" version of each piece is also stored, which is similar to the piece being left-to-right bitswapped.
; 106                     ; However using a dedicated version of the flipped piece removes the need for a bitswap subroutine,
; 107                     ; which actually saves instructions overall, and also allows the pieces to be tweaked so that they rotate correctly.
; 108                     ;
; 109                     ; The Gameboy left-handed rotation system was used as a reference, but the code doesn't attempt to exactly adhere to any particular system,
; 110                     ; it just attempts to look somewhat acceptable and use minimal instructions.
; 111                     
; 112                     
; 113                     ; I piece
; 114                     ;
; 115                     ;3   7
; 116                     ; 0 1
; 117                     ; 0 1
; 118                     ; 0 1
; 119                     ; 0 1
; 120                     ;0   4
; 121     0000_0002       I_PIECE	equ	0xF0
; 122     0000_0002       I_PIECE_FLIP	equ	I_PIECE	; I piece is the same flipped
; 123                     
; 124                     ; O (square) piece
; 125                     ;
; 126                     ;3   7
; 127                     ; 0 0
; 128                     ; 1 1
; 129                     ; 1 1
; 130                     ; 0 0
; 131                     ;0   4
; 132     0000_0002       O_PIECE	equ	0x66
; 133     0000_0002       O_PIECE_FLIP	equ	O_PIECE	; Square is same in any rotation
; 134                     
; 135                     ; T piece
; 136                     ;
; 137                     ;3   7
; 138                     ; 0 0
; 139                     ; 1 0
; 140                     ; 1 1
; 141                     ; 1 0
; 142                     ;0   4
; 143     0000_0002       T_PIECE	equ	0x27
; 144                     
; 145                     ; T piece flipped
; 146                     ;
; 147                     ;3   7
; 148                     ; 0 0
; 149                     ; 0 1
; 150                     ; 1 1
; 151                     ; 0 1
; 152                     ;0   4
; 153     0000_0002       T_PIECE_FLIP	equ	0x72
; 154                     
; 155                     ; S piece
; 156                     ;
; 157                     ;3   7
; 158                     ; 0 0
; 159                     ; 1 0
; 160                     ; 1 1
; 161                     ; 0 1
; 162                     ;0   4
; 163     0000_0002       S_PIECE	equ	0x36
; 164     0000_0002       S_PIECE_FLIP	equ	S_PIECE	; S piece is the same rotated
; 165                     
; 166                     ; S piece
; 167                     ;
; 168                     ;3   7
; 169                     ; 0 0
; 170                     ; 0 1
; 171                     ; 1 1
; 172                     ; 1 0
; 173                     ;0   4
; 174     0000_0002       Z_PIECE	equ	0x63
; 175     0000_0002       Z_PIECE_FLIP	equ	Z_PIECE	; Z piece is the same rotated
; 176                     
; 177                     ; J piece
; 178                     ;
; 179                     ;3   7
; 180                     ; 0 0
; 181                     ; 0 1
; 182                     ; 0 1
; 183                     ; 1 1
; 184                     ;0   4
; 185     0000_0002       J_PIECE	equ	0x71
; 186                     
; 187                     ; J piece flipped
; 188                     ;
; 189                     ;3   7
; 190                     ; 0 0
; 191                     ; 1 1
; 192                     ; 1 0
; 193                     ; 1 0
; 194                     ;0   4
; 195     0000_0002       J_PIECE_FLIP	equ	0x47
; 196                     
; 197                     ; L piece
; 198                     ;
; 199                     ;3   7
; 200                     ; 0 0
; 201                     ; 1 0
; 202                     ; 1 0
; 203                     ; 1 1
; 204                     ;0   4
; 205     0000_0002       L_PIECE	equ	0x17
; 206                     
; 207                     ; L piece flipped
; 208                     ;
; 209                     ;3   7
; 210                     ; 0 0
; 211                     ; 1 1
; 212                     ; 0 1
; 213                     ; 0 1
; 214                     ;0   4
; 215     0000_0002       L_PIECE_FLIP	equ	0x74
; 216                     
; 217                     ; Start of application code
; 218                     ;
; 219     02              test_piece_loop_i	skip	1
; 220     03              test_piece_loop_j	skip	1
; 221                     
; 223                     
; 224     04 4800_00b1    	clr	piece_kind
; 225     05 4800_00b2    	clr	piece_rotation
; 226     06 4800_03b3    	st	#3,	piece_x
; 227     07 4800_00b4    	clr	piece_y
; 228                     
; 253                     
; 278     08 8408_7867    	jsr	render_board_ret,	render_board
; 280     09 d800_0d00    	outc	#CR_CHAR
; 281     0a d800_0a00    	outc	#LF_CHAR
; 284     0b 8408_8e7a    	jsr	line_clr_ret,	line_clr
; 287     0c 8408_7867    	jsr	render_board_ret,	render_board
; 289     0d d800_0d00    	outc	#CR_CHAR
; 290     0e d800_0a00    	outc	#LF_CHAR
; 292     0f 4800_f902    	st	#-7,	test_piece_loop_i
; 294     10 4800_00b2    	clr	piece_rotation
; 295     11 4800_fc03    	st	#-4,	test_piece_loop_j
; 298     12 8408_d6ce    	jsr	clear_piece_stage_ret,	clear_piece_stage
; 301     13 0800_b128    	st	piece_kind,	prep_piece_number
; 302     14 0800_b223    	st	piece_rotation,	prep_piece_rot
; 303     15 8408_4a24    	jsr	prep_piece_ret,	prep_piece
; 306     16 4800_5c57    	st	#stamp_piece_merge_op,	stamp_piece_op
; 307     17 8408_644d    	jsr	stamp_piece_ret,	stamp_piece
; 310     18 8408_7867    	jsr	render_board_ret,	render_board
; 312     19 d800_0d00    	outc	#CR_CHAR
; 313     1a d800_0a00    	outc	#LF_CHAR
; 316     1b 4800_5e57    	st	#stamp_piece_clear_op,	stamp_piece_op
; 317     1c 8408_644d    	jsr	stamp_piece_ret,	stamp_piece
; 319     1d 4880_01b2    	inc	piece_rotation
; 320     1e 802a_0312    	incjne	test_piece_loop_j,	test_piece_loop_b
; 321     1f 4880_01b1    	inc	piece_kind
; 322     20 802a_0210    	incjne	test_piece_loop_i,	test_piece_loop_a
; 325     21 d800_2100    	outc	#33	; !
; 326     22 c810_ff00    	halt
; 327                     
; 328                     ; Prepare piece stage subroutine
; 329                     ; prep_piece_number = which piece to render. {0,1,2,3,4,5,6}
; 330                     ;
; 331                     ; Piece rotation. 4 different values for each direction. {0,1,2,3}.
; 332                     ;
; 333                     ; prep_piece_number is consumed during this operation.
; 334                     ;
; 335     23              prep_piece_rot	skip	1
; 345     24 0a00_2300    	lsrto	prep_piece_rot,	tmp
; 346     25 0a00_0000    	lsr	tmp
; 347     26 0890_2828    	adcto	prep_piece_number,	prep_piece_number
; 349     27 4880_2928    	addto	#prep_piece_jmp,	prep_piece_number
; 351     28 4018_ff00    prep_piece_number	jmp	0
; 353     29 4808_6637    	insn ST_JMP_INSN	#O_PIECE,	prep_piece_value
; 354     2a 4808_6637    	insn ST_JMP_INSN	#O_PIECE_FLIP,	prep_piece_value
; 355     2b 4808_f037    	insn ST_JMP_INSN	#I_PIECE,	prep_piece_value
; 356     2c 4808_f037    	insn ST_JMP_INSN	#I_PIECE_FLIP,	prep_piece_value
; 357     2d 4808_2737    	insn ST_JMP_INSN	#T_PIECE,	prep_piece_value
; 358     2e 4808_7237    	insn ST_JMP_INSN	#T_PIECE_FLIP,	prep_piece_value
; 359     2f 4808_3637    	insn ST_JMP_INSN	#S_PIECE,	prep_piece_value
; 360     30 4808_3637    	insn ST_JMP_INSN	#S_PIECE_FLIP,	prep_piece_value
; 361     31 4808_6337    	insn ST_JMP_INSN	#Z_PIECE,	prep_piece_value
; 362     32 4808_6337    	insn ST_JMP_INSN	#Z_PIECE_FLIP,	prep_piece_value
; 363     33 4808_7137    	insn ST_JMP_INSN	#J_PIECE,	prep_piece_value
; 364     34 4808_4737    	insn ST_JMP_INSN	#J_PIECE_FLIP,	prep_piece_value
; 365     35 4808_1737    	insn ST_JMP_INSN	#L_PIECE,	prep_piece_value
; 366     36 4808_7437    	insn ST_JMP_INSN	#L_PIECE_FLIP,	prep_piece_value
; 367     37 4010_ff00    prep_piece_value	nop	; prep_piece_value stores the jump table result.
; 368                     
; 370     38 0202_2340    	jo	prep_piece_rot,	prep_piece_hor
; 372     39 0800_37d3    	st	prep_piece_value,	piece_stage+5
; 373     3a 4980_f0d3    	andto	#0xF0,	piece_stage+5	; Clear lower 4 bits
; 374     3b 4800_fc00    	st	#-4,	tmp
; 375     3c 0880_3737    prep_piece_vert_loop	lsl	prep_piece_value
; 376     3d 802a_003c    	incjne	tmp,	prep_piece_vert_loop
; 377     3e 0800_37d1    	st	prep_piece_value,	piece_stage+3
; 378     3f 4018_ff4a    	jmp	prep_piece_ret
; 380     0000_0040       prep_piece_hor_i	equ	prep_piece_number	; Reuse prep_piece_number as the outer loop variable
; 381     40 4800_fd28    	st	#-3,	prep_piece_hor_i
; 383     41 4800_d543    	st	#(piece_stage+7),	prep_piece_hor_ptr
; 385     42 0800_4345    	st	prep_piece_hor_ptr,	prep_piece_hor_wb_ptr
; 387                     ;prep_piece_hor_ptr	add	#tmp,	0	; LOAD
; 388     43 c080_0000    prep_piece_hor_ptr	insn IMADD_INSN	tmp,	0	; LOAD
; 389     44 0a00_3737    	lsr	prep_piece_value
; 390     45 0a10_0000    prep_piece_hor_wb_ptr	rorto	tmp,	0	; STORE
; 391     46 48e0_0243    	rsbto	#2,	prep_piece_hor_ptr
; 392     47 40e0_ce43    	insn ALEB_TOC_INSN	#piece_stage,	prep_piece_hor_ptr
; 393     48 006c_0042    	jcs	prep_piece_hor_loop_b		; Jump if prep_piece_hor_ptr < #piece_stage
; 394     49 802a_2841    	incjne	prep_piece_hor_i,	prep_piece_hor_loop_a
; 395     4a 4018_ff00    prep_piece_ret	jmp	0
; 396                     
; 397                     ; Stamp piece board subroutine.
; 398                     ;
; 399                     ; This subroutine handles several functions:
; 400                     ;
; 401                     ; * ADDing the piece_stage to the gameboard (Stamping the piece down)
; 402                     ; * BICing the piece_stage to the gameboard (Clearing the piece off)
; 403                     ; * Checking for any common bits (AND result > 0) between piece_stage and gameboard (Checking for collision).
; 404                     ;
; 405                     ; stamp_piece_op must be set to #stamp_piece_coll_op, #stamp_piece_merge_op, or #stamp_piece_clear_op before executing.
; 406                     ;
; 407                     ; When executing stamp_piece_coll_op, tmp will be non-zero if a collision occured.
; 408                     ;
; 409     4b              stamp_piece_ps_val	skip	1
; 410     4c              stamp_piece_gb_val	skip	1
; 414     4d 4800_ce54    	st	#piece_stage,	stamp_piece_ps_ptr
; 415     4e 4800_b756    	st	#gameboard,	stamp_piece_gb_ptr
; 416     4f 0800_b300    	st	piece_x,	tmp
; 417     50 0880_0000    	lsl	tmp	; Multiply piece_x by 2 to get gameboard ptr offset
; 418     51 0880_0056    	addto	tmp,	stamp_piece_gb_ptr
; 421     52 4800_f800    	st	#-PIECE_STAGE_SIZE,	tmp
; 423     53 4800_004b    	clr	stamp_piece_ps_val
; 424     54 8080_4b00    stamp_piece_ps_ptr	add	stamp_piece_ps_val,	0	; Piece stage LOAD
; 426     55 4800_004c    	clr	stamp_piece_gb_val
; 427     56 8080_4c00    stamp_piece_gb_ptr	add	stamp_piece_gb_val,	0	; Game board LOAD
; 428                     
; 430     57 4018_ff00    stamp_piece_op	jmp	0	; This is set before calling the subroutine
; 433     58 0980_4b4c    	andto	stamp_piece_ps_val,	stamp_piece_gb_val
; 434     59 020a_4c61    	je	stamp_piece_gb_val,	stamp_piece_loop_end
; 435     5a 0800_4c00    	st	stamp_piece_gb_val,	tmp	; Store colliding bits in tmp
; 436     5b 4018_ff64    	jmp	stamp_piece_ret
; 440     5c 0880_4b4c    	addto	stamp_piece_ps_val,	stamp_piece_gb_val
; 441     5d 4018_ff5f    	jmp	stamp_piece_writeback
; 443     5e 09c0_4b4c    	bicto	stamp_piece_ps_val,	stamp_piece_gb_val
; 445     5f 0800_5660    	st	stamp_piece_gb_ptr,	stamp_piece_gb_wb_ptr
; 446     60 0800_4c00    stamp_piece_gb_wb_ptr	st	stamp_piece_gb_val,	0
; 449     61 4880_0154    	inc	stamp_piece_ps_ptr
; 450     62 4880_0156    	inc	stamp_piece_gb_ptr
; 451     63 802a_0053    	incjne	tmp,	stamp_piece_loop
; 452     64 4018_ff00    stamp_piece_ret	jmp	0	; Return from subroutine
; 453                     
; 454                     ; Render board subroutine
; 455                     ;
; 456                     ; How:
; 457                     ; Render the gameboard from left to right, top to bottom, to give the most simple console output (avoids ANSI console cursor movement).
; 458                     ;
; 459                     ; LOOP A: Starts at top of the board and then switches to bottom half of the board. The gameboard ptr offset changes from 1 to 0. (or 2 -> 1 -> 0 if using a bigger game board)
; 460                     ; LOOP B: Work down the rows using a single byte bitmask, shifting it right each iteration.
; 461                     ; LOOP C: Work along the columns from 0 to 10, incrementing the gameboard ptr by 2 each iteration.
; 462                     ;         Decide whether to render a block or empty character by ANDing the gameboard ptr value with the current bitmask
; 463                     
; 464                     ; Temporary variables for internal use
; 465     65              render_board_mask	skip	1 ; The row bitmask for selecting the row to render
; 466     66              render_board_col	skip	1 ; The current column iteration loop counter.
; 467                     
; 469     67 4800_016c    	st	#(GAMEBOARD_STRIDE-1),	render_board_ptr	; Start the render_board_ptr with an offset of 1 to render the top half of the board.
; 470                     ; LOOP A
; 472     68 4880_b76c    	addto	#gameboard,	render_board_ptr	; Adjust the render_board_ptr to point into the gameboard
; 473     69 4800_8065    	st	#%1000_0000,	render_board_mask	; Initialize the bitmask for testing the column byte for which row is set
; 474                     ; LOOP B
; 476     6a 4800_f666    	st	#(-GAMEBOARD_COLS),	render_board_col	; Prepare column loop counter
; 477                     ; LOOP C
; 479     6b 0800_6500    	st	render_board_mask,	tmp
; 480     6c 8180_0000    render_board_ptr	insn AND_INSN	tmp,	0	; Indirect AND, store result in tmp
; 483     6d 006a_006f    	jne	tmp,	render_board_print_a
; 484     6e d808_7e70    	insn OUTC_JMP_INSN	#EMPTY_CHAR,	render_board_print_b	; Print empty char and jump over the block char print
; 485     6f d800_2300    render_board_print_a	outc	#BLOCK_CHAR
; 487     70 4880_026c    	addto	#GAMEBOARD_STRIDE,	render_board_ptr	; Move onto next column byte
; 488     71 802a_666b    	incjne	render_board_col,	render_board_loop_c	; If we still have columns to render, continue LOOP C
; 489                     ; END LOOP C
; 490     72 48e0_146c    	rsbto	#GAMEBOARD_SIZE,	render_board_ptr	; Reset render_board_ptr to pre-loop state
; 493     73 d800_0d00    	outc	#CR_CHAR
; 494     74 d800_0a00    	outc	#LF_CHAR
; 495                     
; 498     75 820a_656a    	insn LSR_JCC_INSN	render_board_mask,	render_board_loop_b
; 499                     ; END LOOP B
; 502     76 48e0_b86c    	rsbto	#(gameboard+1),	render_board_ptr
; 504     77 0069_6c68    	jge	render_board_ptr,	render_board_loop_a	; Otherwise continue LOOP A.
; 505                     ; END LOOP A
; 506     78 4018_ff00    render_board_ret	jmp	0		; Return from subroutine.
; 507                     
; 508                     ; line_clr
; 509                     ;
; 510                     ; Clears all full rows from the gameboard.
; 511                     ;
; 512                     ; How:
; 513                     ; 1. Call get_full_lines to generate a bitmask of all the complete rows
; 514                     ; 2. Call rem_bits on each column in the gameboard with a copy of the complete rows bitmask.
; 515                     ; 3. Copy the result back over the gameboard.
; 516                     ;
; 517     79              line_clr_i	skip	1	; We cannot use tmp as loop counter since we call subroutines which overwrite tmp.
; 520     7a 8408_9a91    	jsr	get_full_lines_ret,	get_full_lines
; 521                     
; 523     7b 006a_8f7e    	jne	get_full_lines_mask+0,	line_clr_do_remove
; 524     7c 006a_907e    	jne	get_full_lines_mask+1,	line_clr_do_remove
; 525     7d 4018_ff8e    	jmp	line_clr_ret	; Fastpath to returning from the subroutine
; 526                     
; 528                     
; 531     7e 4800_009d    	clr	rem_bits_value+0
; 532     7f 4800_009e    	clr	rem_bits_value+1
; 533                     
; 535     80 4800_f679    	st	#(-GAMEBOARD_COLS),	line_clr_i	; Prep the loop counter
; 536                     
; 538     81 4800_b785    	st	#gameboard,	line_clr_read_ptr_0
; 540                     
; 541                     ; Line clear loop. It will call rem_bits with the line clear mask and each column of the gameboard.
; 545     82 0800_8f9b    	st	get_full_lines_mask+0,	rem_bits_mask+0	; Prep mask +0
; 546     83 0800_909c    	st	get_full_lines_mask+1,	rem_bits_mask+1	; Prep mask +1
; 547                     
; 549     84 0820_8586    	insn INCTO_INSN	line_clr_read_ptr_0,	line_clr_read_ptr_1	; Prep ptr +1
; 551     85 8080_9d00    line_clr_read_ptr_0	add	rem_bits_value+0,	0	; Load +0
; 552     86 8080_9e00    line_clr_read_ptr_1	add	rem_bits_value+1,	0	; Load +1
; 553                     
; 555     87 8408_afa1    	jsr	rem_bits_ret,	rem_bits
; 556                     
; 558     88 0800_858a    	st	line_clr_read_ptr_0,	line_clr_write_ptr_0	; Prep ptr +0
; 559     89 0800_868b    	st	line_clr_read_ptr_1,	line_clr_write_ptr_1	; Prep ptr +1
; 561     8a 0800_9f00    line_clr_write_ptr_0	st	rem_bits_result+0,	0	; Store +0
; 562     8b 0800_a000    line_clr_write_ptr_1	st	rem_bits_result+1,	0	; Store +1
; 563                     
; 565     8c 4880_0285    	addto	#2,	line_clr_read_ptr_0	; Iterate ptr +0
; 566     8d 802a_7982    	incjne	line_clr_i,	line_clr_loop	; Loop
; 567     8e 4018_ff00    line_clr_ret	jmp	0		; Return from subroutine
; 568                     
; 569                     ; get_full_lines
; 570                     ;
; 571                     ; Generates a 2 byte, 16 bit bitmask indicating which rows in the gameboard are filled.
; 572                     ; This is the bitwise AND of all columns in the gameboard.
; 573                     ;
; 574     8f              get_full_lines_mask	skip	2
; 575                     
; 577     91 4800_f600    	st	#(-GAMEBOARD_COLS),	tmp
; 578     92 4800_ff8f    	st	#0xFF,	get_full_lines_mask+0
; 579     93 4800_ff90    	st	#0xFF,	get_full_lines_mask+1
; 580     94 4800_b796    	st	#gameboard,	get_full_lines_ptr_0
; 582     95 0820_9697    	insn INCTO_INSN	get_full_lines_ptr_0,	get_full_lines_ptr_1
; 583     96 8180_8f00    get_full_lines_ptr_0	insn AND_INSN	get_full_lines_mask+0,	0
; 584     97 8180_9000    get_full_lines_ptr_1	insn AND_INSN	get_full_lines_mask+1,	0
; 585     98 4880_0296    	addto	#2,	get_full_lines_ptr_0
; 586     99 802a_0095    	incjne	tmp,	get_full_lines_loop
; 587     9a 4018_ff00    get_full_lines_ret	jmp	0		; Return from subroutine
; 588                     
; 589                     ; rem_bits
; 590                     ;
; 591                     ; Remove the bits from rem_bits_value in the positions they are set in rem_bits_mask.
; 592                     ; For each bit removed, the more significant bits are shifted right to fill its place.
; 593                     ; The leftmost most significant bits are filled with zeroes.
; 594                     ;
; 595                     ; The output is placed in rem_bits_result.
; 596                     ; rem_bits_mask and rem_bits_value are zeroed as a result of this process.
; 597                     ;
; 598     9b              rem_bits_mask	skip	2
; 599     9d              rem_bits_value	skip	2
; 600     9f              rem_bits_result	skip	2
; 603     a1 4800_009f    	clr	rem_bits_result+0
; 604     a2 4800_00a0    	clr	rem_bits_result+1
; 605     a3 4800_f000    	st	#-16,	tmp	; Loop 16 times
; 607     a4 0880_9b9b    	lsl	rem_bits_mask+0		; Logical shift left mask (0 -> bit 0)
; 608     a5 0890_9c9c    	rol	rem_bits_mask+1		; (bit 15 -> carry)
; 609     a6 0064_00aa    	jcc	rem_bits_A		; GOTO A if carry clear
; 611     a7 0880_9d9d    	lsl	rem_bits_value+0		; Logical shift left value (0 -> bit 0)
; 612     a8 0890_9e9e    	rol	rem_bits_value+1		; The carry result is discarded.
; 613     a9 4018_ffae    	jmp	rem_bits_loop_end
; 615     aa 0880_9d9d    	lsl	rem_bits_value+0		; Logical shift left value (0 -> bit 0)
; 616     ab 0890_9e9e    	rol	rem_bits_value+1		; (bit 15 -> carry)
; 617     ac 0890_9f9f    	rol	rem_bits_result+0		; Rotate left to save the carry into result (carry -> bit 0)
; 618     ad 0890_a0a0    	rol	rem_bits_result+1		; Carry from rotating result is discarded.
; 619     ae 802a_00a4    rem_bits_loop_end	incjne	tmp,	rem_bits_loop	; Loop
; 620     af 4018_ff00    rem_bits_ret	jmp	0		; Return from subroutine
; 621                     
; 622                     ; VARIABLES
; 623                     
; 624                     ; Game state
; 625                     ;
; 626     b0              lines_cleared	skip	1
; 627                     
; 628     b1              piece_kind	skip	1
; 629     b2              piece_rotation	skip	1
; 630     b3              piece_x	skip	1
; 631     b4              piece_y	skip	1
; 632                     
; 633                     ; Game board
; 634                     ;
; 635                     ; The gameboard is made up of bytes stacked vertically.
; 636                     ; There are two bytes end to end for each column, 10 colums wide.
; 637                     ; This makes a 16x10 game board, totalling 20 bytes.
; 638                     ; The lower, even index byte is at the bottom of the board. The higher, odd index byte is at the top.
; 639                     ; The less significant bits in each byte are towards the bottom of the board, the higher significant bits are towards the top.
; 640                     ;
; 641                     ; Ideally we would use three bytes per row to make a 24x10 gameboard in 30 bytes,
; 642                     ; but this increases both gameboard storage size and the code required to deal with it.
; 643                     ;
; 644                     ; Gameboard layout (byte.bit):
; 645                     ;
; 646                     ; 1.7 3.7 5.7 7.7 9.7 11.7 13.7 15.7 17.7 19.7
; 647                     ; 1.6 3.6 5.6 7.6 9.6 11.6 13.6 15.6 17.6 19.6
; 648                     ; 1.5 3.5 5.5 7.5 9.5 11.5 13.5 15.5 17.5 19.5
; 649                     ; 1.4 3.4 5.4 7.4 9.4 11.4 13.4 15.4 17.4 19.4
; 650                     ; 1.3 3.3 5.3 7.3 9.3 11.3 13.3 15.3 17.3 19.3
; 651                     ; 1.2 3.2 5.2 7.2 9.2 11.2 13.2 15.2 17.2 19.2
; 652                     ; 1.1 3.1 5.1 7.1 9.1 11.1 13.1 15.1 17.1 19.1
; 653                     ; 1.0 3.0 5.0 7.0 9.0 11.0 13.0 15.0 17.0 19.0
; 654                     ; 0.7 2.7 4.7 6.7 8.7 10.7 12.7 14.7 16.7 18.7
; 655                     ; 0.6 2.6 4.6 6.6 8.6 10.6 12.6 14.6 16.6 18.6
; 656                     ; 0.5 2.5 4.5 6.5 8.5 10.5 12.5 14.5 16.5 18.5
; 657                     ; 0.4 2.4 4.4 6.4 8.4 10.4 12.4 14.4 16.4 18.4
; 658                     ; 0.3 2.3 4.3 6.3 8.3 10.3 12.3 14.3 16.3 18.3
; 659                     ; 0.2 2.2 4.2 6.2 8.2 10.2 12.2 14.2 16.2 18.2
; 660                     ; 0.1 2.1 4.1 6.1 8.1 10.1 12.1 14.1 16.1 18.1
; 661                     ; 0.0 2.0 4.0 6.0 8.0 10.0 12.0 14.0 16.0 18.0
; 662                     ;
; 663                     ; Neat trick: Since every instruction of the gameboard would normally be a HALT instruction and mostly wasted,
; 664                     ; we can actually use the instruction to clear it's own B value. This gives us gameboard clearing and piece stage clearing "for free".
; 665                     
; 666     b5 c810_ffff    	data	0xFF		; A wall for the gameboard to provide collisions at -1
; 667     b6 c810_ffff    	data	0xFF
; 670     b7 8100_b700    	insn CLRA_INSN	gameboard+0,	0
; 671     b8 8100_b800    	insn CLRA_INSN	gameboard+1,	0
; 672     b9 8100_b900    	insn CLRA_INSN	gameboard+2,	0
; 673     ba 8100_ba00    	insn CLRA_INSN	gameboard+3,	0
; 674     bb 8100_bb00    	insn CLRA_INSN	gameboard+4,	0
; 675     bc 8100_bc00    	insn CLRA_INSN	gameboard+5,	0
; 676     bd 8100_bd00    	insn CLRA_INSN	gameboard+6,	0
; 677     be 8100_be00    	insn CLRA_INSN	gameboard+7,	0
; 678     bf 8100_bf00    	insn CLRA_INSN	gameboard+8,	0
; 679     c0 8100_c000    	insn CLRA_INSN	gameboard+9,	0
; 680     c1 8100_c100    	insn CLRA_INSN	gameboard+10,	0
; 681     c2 8100_c200    	insn CLRA_INSN	gameboard+11,	0
; 682     c3 8100_c300    	insn CLRA_INSN	gameboard+12,	0
; 683     c4 8100_c400    	insn CLRA_INSN	gameboard+13,	0
; 684     c5 8100_c500    	insn CLRA_INSN	gameboard+14,	0
; 685     c6 8100_c600    	insn CLRA_INSN	gameboard+15,	0
; 686     c7 8100_c700    	insn CLRA_INSN	gameboard+16,	0
; 687     c8 8100_c800    	insn CLRA_INSN	gameboard+17,	0
; 688     c9 8100_c900    	insn CLRA_INSN	gameboard+18,	0
; 689     ca 8100_ca00    	insn CLRA_INSN	gameboard+19,	0
; 690     cb 0000_00ff    	insn 0x00000000	,	0xFF	; no-op/clc, but specified as custom instruction se we can set B value.
; 691     cc 0000_00ff    	insn 0x00000000	,	0xFF	; A wall for the gameboard to provide collisions at 11
; 692     cd 4018_ff00    clear_gameboard_ret	jmp	0	; Return from subroutine
; 694                     
; 695                     ; Piece stage
; 696                     ;
; 697                     ; Piece stage layout (byte.bit):
; 698                     ;
; 699                     ; 1.7 3.7 5.7 7.7
; 700                     ; 1.6 3.6 5.6 7.6
; 701                     ; 1.5 3.5 5.5 7.5
; 702                     ; 1.4 3.4 5.4 7.4
; 703                     ; 1.3 3.3 5.3 7.3
; 704                     ; 1.2 3.2 5.2 7.2
; 705                     ; 1.1 3.1 5.1 7.1
; 706                     ; 1.0 3.0 5.0 7.0
; 707                     ; 0.7 2.7 4.7 6.7
; 708                     ; 0.6 2.6 4.6 6.6
; 709                     ; 0.5 2.5 4.5 6.5
; 710                     ; 0.4 2.4 4.4 6.4
; 711                     ; 0.3 2.3 4.3 6.3
; 712                     ; 0.2 2.2 4.2 6.2
; 713                     ; 0.1 2.1 4.1 6.1
; 714                     ; 0.0 2.0 4.0 6.0
; 715                     ;
; 718     ce 8100_ce00    	insn CLRA_INSN	piece_stage+0,	0
; 719     cf 8100_cf00    	insn CLRA_INSN	piece_stage+1,	0
; 720     d0 8100_d000    	insn CLRA_INSN	piece_stage+2,	0
; 721     d1 8100_d100    	insn CLRA_INSN	piece_stage+3,	0
; 722     d2 8100_d200    	insn CLRA_INSN	piece_stage+4,	0
; 723     d3 8100_d300    	insn CLRA_INSN	piece_stage+5,	0
; 724     d4 8100_d400    	insn CLRA_INSN	piece_stage+6,	0
; 725     d5 8100_d500    	insn CLRA_INSN	piece_stage+7,	0
; 726     d6 4018_ff00    clear_piece_stage_ret	jmp	0
; 727                     
; 728                     ; Placeholder label to easily see how big the program is from the symbol table

; 0 errors detected in pass 2

; Symbol table:
; ALEB_TOC_INSN = 0xe00000
; ALTB_TOC_INSN = 0xc00000
; AND_INSN = 0x81800000
; A_CHAR = 0x41
; BAR_CHAR = 0x7c
; BLOCK_CHAR = 0x23
; B_CHAR = 0x42
; CLRA_INSN = 0x81000000
; CR_CHAR = 0xd
; C_CHAR = 0x43
; D_CHAR = 0x44
; EMPTY_CHAR = 0x7e
; END_OF_PROGRAM = 0xd7
; E_CHAR = 0x45
; F_CHAR = 0x46
; GAMEBOARD_COLS = 0xa
; GAMEBOARD_SIZE = 0x14
; GAMEBOARD_STRIDE = 0x2
; G_CHAR = 0x47
; H_CHAR = 0x48
; IMADD_INSN = 0xc0800000
; INCTO_INSN = 0x8200000
; I_CHAR = 0x49
; I_PIECE = 0xf0
; I_PIECE_FLIP = 0xf0
; J_CHAR = 0x4a
; J_PIECE = 0x71
; J_PIECE_FLIP = 0x47
; K_CHAR = 0x4b
; LF_CHAR = 0xa
; LSR_JCC_INSN = 0x820a0000
; L_CHAR = 0x4c
; L_PIECE = 0x17
; L_PIECE_FLIP = 0x74
; M_CHAR = 0x4d
; N_CHAR = 0x4e
; OUTC_JMP_INSN = 0x98080000
; O_CHAR = 0x4f
; O_PIECE = 0x66
; O_PIECE_FLIP = 0x66
; PIECE_STAGE_SIZE = 0x8
; P_CHAR = 0x50
; Q_CHAR = 0x51
; R_CHAR = 0x52
; SPACE_CHAR = 0x20
; ST_JMP_INSN = 0x8080000
; S_CHAR = 0x53
; S_PIECE = 0x36
; S_PIECE_FLIP = 0x36
; T_CHAR = 0x54
; T_PIECE = 0x27
; T_PIECE_FLIP = 0x72
; U_CHAR = 0x55
; V_CHAR = 0x56
; W_CHAR = 0x57
; X_CHAR = 0x58
; Y_CHAR = 0x59
; ZERO_CHAR = 0x30
; Z_CHAR = 0x5a
; Z_PIECE = 0x63
; Z_PIECE_FLIP = 0x63
; clear_gameboard = 0xb7
; clear_gameboard_ret = 0xcd
; clear_piece_stage = 0xce
; clear_piece_stage_ret = 0xd6
; exec = 0x1
; gameboard = 0xb7
; get_full_lines = 0x91
; get_full_lines_loop = 0x95
; get_full_lines_mask = 0x8f
; get_full_lines_ptr_0 = 0x96
; get_full_lines_ptr_1 = 0x97
; get_full_lines_ret = 0x9a
; line_clr = 0x7a
; line_clr_do_remove = 0x7e
; line_clr_i = 0x79
; line_clr_loop = 0x82
; line_clr_read_ptr_0 = 0x85
; line_clr_read_ptr_1 = 0x86
; line_clr_ret = 0x8e
; line_clr_write_ptr_0 = 0x8a
; line_clr_write_ptr_1 = 0x8b
; lines_cleared = 0xb0
; piece_kind = 0xb1
; piece_rotation = 0xb2
; piece_stage = 0xce
; piece_x = 0xb3
; piece_y = 0xb4
; prep_piece = 0x24
; prep_piece_hor = 0x40
; prep_piece_hor_i = 0x28
; prep_piece_hor_loop_a = 0x41
; prep_piece_hor_loop_b = 0x42
; prep_piece_hor_ptr = 0x43
; prep_piece_hor_wb_ptr = 0x45
; prep_piece_jmp = 0x29
; prep_piece_number = 0x28
; prep_piece_ret = 0x4a
; prep_piece_rot = 0x23
; prep_piece_value = 0x37
; prep_piece_vert = 0x39
; prep_piece_vert_loop = 0x3c
; rem_bits = 0xa1
; rem_bits_A = 0xaa
; rem_bits_loop = 0xa4
; rem_bits_loop_end = 0xae
; rem_bits_mask = 0x9b
; rem_bits_result = 0x9f
; rem_bits_ret = 0xaf
; rem_bits_value = 0x9d
; render_board = 0x67
; render_board_col = 0x66
; render_board_loop_a = 0x68
; render_board_loop_b = 0x6a
; render_board_loop_c = 0x6b
; render_board_mask = 0x65
; render_board_print_a = 0x6f
; render_board_print_b = 0x70
; render_board_ptr = 0x6c
; render_board_ret = 0x78
; run = 0x4
; stamp_piece = 0x4d
; stamp_piece_clear_op = 0x5e
; stamp_piece_coll_op = 0x58
; stamp_piece_gb_ptr = 0x56
; stamp_piece_gb_val = 0x4c
; stamp_piece_gb_wb_ptr = 0x60
; stamp_piece_loop = 0x53
; stamp_piece_loop_end = 0x61
; stamp_piece_merge_op = 0x5c
; stamp_piece_op = 0x57
; stamp_piece_ps_ptr = 0x54
; stamp_piece_ps_val = 0x4b
; stamp_piece_ret = 0x64
; stamp_piece_writeback = 0x5f
; test_piece_loop_a = 0x10
; test_piece_loop_b = 0x12
; test_piece_loop_i = 0x2
; test_piece_loop_j = 0x3
; tmp = 0x0

; Memory image:
00: c810ff00 4018ff04
04: 480000b1 480000b2 480003b3 480000b4
08: 84087867 d8000d00 d8000a00 84088e7a 84087867 d8000d00 d8000a00 4800f902
10: 480000b2 4800fc03 8408d6ce 0800b128 0800b223 84084a24 48005c57 8408644d
18: 84087867 d8000d00 d8000a00 48005e57 8408644d 488001b2 802a0312 488001b1
20: 802a0210 d8002100 c810ff00
24: 0a002300 0a000000 08902828 48802928
28: 4018ff00 48086637 48086637 4808f037 4808f037 48082737 48087237 48083637
30: 48083637 48086337 48086337 48087137 48084737 48081737 48087437 4010ff00
38: 02022340 080037d3 4980f0d3 4800fc00 08803737 802a003c 080037d1 4018ff4a
40: 4800fd28 4800d543 08004345 c0800000 0a003737 0a100000 48e00243 40e0ce43
48: 006c0042 802a2841 4018ff00
4d: 4800ce54 4800b756 0800b300
50: 08800000 08800056 4800f800 4800004b 80804b00 4800004c 80804c00 4018ff00
58: 09804b4c 020a4c61 08004c00 4018ff64 08804b4c 4018ff5f 09c04b4c 08005660
60: 08004c00 48800154 48800156 802a0053 4018ff00
67: 4800016c
68: 4880b76c 48008065 4800f666 08006500 81800000 006a006f d8087e70 d8002300
70: 4880026c 802a666b 48e0146c d8000d00 d8000a00 820a656a 48e0b86c 00696c68
78: 4018ff00
7a: 84089a91 006a8f7e 006a907e 4018ff8e 4800009d 4800009e
80: 4800f679 4800b785 08008f9b 0800909c 08208586 80809d00 80809e00 8408afa1
88: 0800858a 0800868b 08009f00 0800a000 48800285 802a7982 4018ff00
91: 4800f600 4800ff8f 4800ff90 4800b796 08209697 81808f00 81809000
98: 48800296 802a0095 4018ff00
a1: 4800009f 480000a0 4800f000 08809b9b 08909c9c 006400aa 08809d9d
a8: 08909e9e 4018ffae 08809d9d 08909e9e 08909f9f 0890a0a0 802a00a4 4018ff00
b5: c810ffff c810ffff 8100b700
b8: 8100b800 8100b900 8100ba00 8100bb00 8100bc00 8100bd00 8100be00 8100bf00
c0: 8100c000 8100c100 8100c200 8100c300 8100c400 8100c500 8100c600 8100c700
c8: 8100c800 8100c900 8100ca00 000000ff 000000ff 4018ff00 8100ce00 8100cf00
d0: 8100d000 8100d100 8100d200 8100d300 8100d400 8100d500 4018ff00
