; Pass 1...
; tetris.asm:271: error: Extra junk at end of line '0'
; tetris.asm:276: error: Missing second operand
; tetris.asm:276: error: Extra junk at end of line 'prep_piece_value,	piece_stage+5'
; tetris.asm:279: error: Unknown instruction 'prep_piece_loop_0a'

; 4 errors detected in pass 1

; Pass 2...
; 1                       ; Tetris implementation
; 2                       ; Ryan Crosby 2022
; 3                       ;
; 4                       ; Run from 0x01.
; 5                       ;
; 6                       ; Completed:
; 7                       ;
; 8                       ; * Gameboard format
; 9                       ; * Gameboard rendering to console
; 10                      ; * Line clearing
; 11                      ;
; 12                      ; ~120 instructions left to implement the rest of TODO.
; 13                      ;
; 14                      ; TODO:
; 15                      ;
; 16                      ;
; 17                      ; * Description with controls etc.
; 18                      ; * Smarter temporary variable management.
; 19                      ;       Define a small section of memory to use like a shared register pool.
; 20                      ;       Go through the subroutines and replace dedicated temporary variables with shared variables from the register pool that haven't been used yet in the execution flow.
; 21                      ;       Also inline most subroutines, most are called from a single spot.
; 22                      
; 23                      ;
; 24                      
; 25                      ; Constants
; 26                      ;
; 27                      
; 28                      ; Gameboard parameters
; 29      0000_0000       GAMEBOARD_STRIDE	equ	2	; How many bytes high is the gameboard. 2 bytes = 16 rows.
; 31      0000_0000       GAMEBOARD_COLS	equ	10	; How many columns wide is the gameboard. This is generic enough that it can be adjusted without altering any code.
; 32      0000_0000       GAMEBOARD_SIZE	equ	(GAMEBOARD_STRIDE*GAMEBOARD_COLS)	; Gameboard total size = stride * columns
; 33                      
; 34      0000_0000       PIECE_STAGE_SIZE	equ	(GAMEBOARD_STRIDE*4)	; The piece stage is the same height as the gameboard, but only 4 wide.
; 35                      
; 36      0000_0000       SPACE_CHAR	equ	0x20	; Space
; 37      0000_0000       BLOCK_CHAR	equ	0x23	; #
; 38      0000_0000       EMPTY_CHAR	equ	0x7E 	; ~
; 39      0000_0000       BAR_CHAR	equ	0x7C	; |
; 40                      
; 41      0000_0000       CR_CHAR	equ	0x0D	; Carriage Return CR \r
; 42      0000_0000       LF_CHAR	equ	0x0A	; Linefeed LF \n
; 43                      
; 44                      ; Number constants
; 45      0000_0000       ZERO_CHAR	equ	0x30	; 0
; 46                      
; 47                      ; Alphabet constants
; 48      0000_0000       A_CHAR	equ	0x41	; A
; 49      0000_0000       B_CHAR	equ	A_CHAR+1
; 50      0000_0000       C_CHAR	equ	A_CHAR+2
; 51      0000_0000       D_CHAR	equ	A_CHAR+3
; 52      0000_0000       E_CHAR	equ	A_CHAR+4
; 53      0000_0000       F_CHAR	equ	A_CHAR+5
; 54      0000_0000       G_CHAR	equ	A_CHAR+6
; 55      0000_0000       H_CHAR	equ	A_CHAR+7
; 56      0000_0000       I_CHAR	equ	A_CHAR+8
; 57      0000_0000       J_CHAR	equ	A_CHAR+9
; 58      0000_0000       K_CHAR	equ	A_CHAR+10
; 59      0000_0000       L_CHAR	equ	A_CHAR+11
; 60      0000_0000       M_CHAR	equ	A_CHAR+12
; 61      0000_0000       N_CHAR	equ	A_CHAR+13
; 62      0000_0000       O_CHAR	equ	A_CHAR+14
; 63      0000_0000       P_CHAR	equ	A_CHAR+15
; 64      0000_0000       Q_CHAR	equ	A_CHAR+16
; 65      0000_0000       R_CHAR	equ	A_CHAR+17
; 66      0000_0000       S_CHAR	equ	A_CHAR+18
; 67      0000_0000       T_CHAR	equ	A_CHAR+19
; 68      0000_0000       U_CHAR	equ	A_CHAR+20
; 69      0000_0000       V_CHAR	equ	A_CHAR+21
; 70      0000_0000       W_CHAR	equ	A_CHAR+22
; 71      0000_0000       X_CHAR	equ	A_CHAR+23
; 72      0000_0000       Y_CHAR	equ	A_CHAR+24
; 73      0000_0000       Z_CHAR	equ	A_CHAR+25
; 74                      
; 75                      ; Additional custom instructions
; 76                      ; To use these, call them like: insn INCTO_INSN aa, bb
; 77      0000_0000       AND_INSN	equ	0x81800000	; The WRA version of andto. ANDs [aa] and [bb], and stores in [aa].
; 78      0000_0000       INCTO_INSN	equ	0x08200000	; Stores [aa] + 1 --> [bb] in one instruction.
; 79      0000_0000       OUTC_JMP_INSN	equ	0x98080000	; Writes [aa] to the console and jumps to bb. WRA and WRB are set to make OUT write to console.
; 80      0000_0000       LSR_JCC_INSN	equ	0x820A0000	; Rotates [aa] right, writes the result back to [aa], and jumps if the shifted out bit (carry output) was clear.
; 81      0000_0000       ST_JMP_INSN	equ	0x08080000	; Stores [aa] --> [bb] and jumps to bb.
; 82                      
; 83                      
; 84                      ; Catch for any jumps to null (0x00). This usually indicates a subroutine hasn't had its return address set.
; 85                      ;
; 86                      ; Also used as a temporary storage register, and sometimes as the return value for subroutines that only need to return a status.
; 87                      
; 88      00              	org	0x00
; 89      00 c810_ff00    tmp	halt
; 90                      
; 91                      ; ENTRY POINT
; 92      01              	org	0x01
; 93      01 4018_ff07    exec	jmp	run	; Jump to start of program
; 94                      
; 95                      
; 96                      ; Pieces templates
; 97                      ;
; 98                      ; Piece patterns are stored as a single byte, represening the piece in its starting/0 pose.
; 99                      ; The byte makes up two rows of 4 colums, which is enough to fit every kind of piece lying "flat".
; 100                     ;
; 101                     ; Bits 0-3 are the bottom row, bits 4-7 are the top row.
; 102                     ; The LSB of the row is the _leftmost_ square, so pieces are rendered left to right LSB to RSB.
; 103                     ; This is the left to right mirror of the way that bits are normally written out
; 104                     ; left to right RSB to LSB, so take care.
; 105                     ;
; 106                     
; 107                     ;; TODO: How do these actually get decoded/used?
; 108                     
; 109                     ; Real | Bits | Hex
; 110                     
; 111                     ; 1111 | 1111 | F
; 112                     ; 0000 | 0000 | 0
; 113     0000_0002       I_PIECE	equ	0xF0
; 114                     
; 115                     ; 0110 | 0110 | 6
; 116                     ; 0110 | 0110 | 6
; 117     0000_0002       O_PIECE	equ	0x66
; 118                     
; 119                     ;
; 120                     ; 1110 | 0111 | 7
; 121                     ; 0100 | 0010 | 2
; 122     0000_0002       T_PIECE	equ	0x72
; 123                     
; 124                     ; 0110 | 0110 | 6
; 125                     ; 1100 | 0011 | 3
; 126     0000_0002       S_PIECE	equ	0x63
; 127                     
; 128                     ; 1100 | 0011 | 3
; 129                     ; 0110 | 0110 | 6
; 130     0000_0002       Z_PIECE	equ	0x36
; 131                     
; 132                     ; 1110 | 0111 | 7
; 133                     ; 0010 | 0100 | 4
; 134     0000_0002       J_PIECE	equ	0x74
; 135                     
; 136                     ; 0010 | 0100 | 4
; 137                     ; 1110 | 0111 | 7
; 138     0000_0002       L_PIECE	equ	0x47
; 139                     
; 140                     
; 141                     ; Game state
; 142                     ;
; 143     02              lines_cleared	skip	1
; 144                     
; 145     03              current_piece	skip	1
; 146     04              current_pose	skip	1
; 147     05              current_x	skip	1
; 148     06              current_y	skip	1
; 149                     
; 150                     
; 151                     
; 152                     ; Start of application code
; 153                     ;
; 179                     
; 181     07 4800_02a3    	st	#%0000_0010,	gameboard+19
; 182     08 4800_02a1    	st	#%0000_0010,	gameboard+17
; 183     09 4800_229f    	st	#%0010_0010,	gameboard+15
; 184     0a 4800_739d    	st	#%0111_0011,	gameboard+13
; 185     0b 4800_029b    	st	#%0000_0010,	gameboard+11
; 186     0c 4800_0299    	st	#%0000_0010,	gameboard+9
; 187     0d 4800_0297    	st	#%0000_0010,	gameboard+7
; 188     0e 4800_0295    	st	#%0000_0010,	gameboard+5
; 189     0f 4800_0793    	st	#%0000_0111,	gameboard+3
; 190     10 4800_3f91    	st	#%0011_1111,	gameboard+1
; 192     11 4800_0fa2    	st	#%0000_1111,	gameboard+18
; 193     12 4800_1fa0    	st	#%0001_1111,	gameboard+16
; 194     13 4800_3f9e    	st	#%0011_1111,	gameboard+14
; 195     14 4800_ff9c    	st	#%1111_1111,	gameboard+12
; 196     15 4800_0f9a    	st	#%0000_1111,	gameboard+10
; 197     16 4800_3f98    	st	#%0011_1111,	gameboard+8
; 198     17 4800_7f96    	st	#%0111_1111,	gameboard+6
; 199     18 4800_0f94    	st	#%0000_1111,	gameboard+4
; 200     19 4800_fd92    	st	#%1111_1101,	gameboard+2
; 201     1a 4800_ff90    	st	#%1111_1111,	gameboard+0
; 204     1b 8408_5847    	jsr	render_board_ret,	render_board
; 206     1c d800_0d00    	outc	#CR_CHAR
; 207     1d d800_0a00    	outc	#LF_CHAR
; 210     1e 8408_6e5a    	jsr	line_clr_ret,	line_clr
; 213     1f 8408_5847    	jsr	render_board_ret,	render_board
; 215     20 d800_0d00    	outc	#CR_CHAR
; 216     21 d800_0a00    	outc	#LF_CHAR
; 219     22 8408_6e5a    	jsr	line_clr_ret,	line_clr
; 222     23 8408_5847    	jsr	render_board_ret,	render_board
; 224     24 d800_0d00    	outc	#CR_CHAR
; 225     25 d800_0a00    	outc	#LF_CHAR
; 228     26 d800_2100    	outc	#33	; !
; 229     27 c810_ff00    	halt
; 231                     ; Prepare piece stage subroutine
; 232                     ; prep_piece_number = which piece to render. {0,1,2,3,4,5,6}
; 233                     ;
; 234                     ; Piece rotation. 4 different values for each direction. {0,1,2,3}.
; 235                     ;
; 236     28              prep_piece_rot	skip	1
; 246     29 0a00_2800    	lsrto	prep_piece_rot,	tmp
; 247     2a 0a00_0000    	lsr	tmp
; 248     2b 0890_2d2d    	adcto	prep_piece_number,	prep_piece_number
; 250     2c 4880_2e2d    	addto	#prep_piece_jmp,	prep_piece_number
; 252     2d 4018_ff00    prep_piece_number	jmp	0
; tetris.asm:255: error: Undefined symbol 'prep_piece_value'
; 255     2e 4808_6600    	insn ST_JMP_INSN	#O_PIECE,	prep_piece_value
; tetris.asm:256: error: Undefined symbol 'O_PIECE_FLIP'
; tetris.asm:256: error: Undefined symbol 'prep_piece_value'
; 256     2f 4808_0000    	insn ST_JMP_INSN	#O_PIECE_FLIP,	prep_piece_value
; tetris.asm:257: error: Undefined symbol 'prep_piece_value'
; 257     30 4808_f000    	insn ST_JMP_INSN	#I_PIECE,	prep_piece_value
; tetris.asm:258: error: Undefined symbol 'I_PIECE_FLIP'
; tetris.asm:258: error: Undefined symbol 'prep_piece_value'
; 258     31 4808_0000    	insn ST_JMP_INSN	#I_PIECE_FLIP,	prep_piece_value
; tetris.asm:259: error: Undefined symbol 'prep_piece_value'
; 259     32 4808_7200    	insn ST_JMP_INSN	#T_PIECE,	prep_piece_value
; tetris.asm:260: error: Undefined symbol 'T_PIECE_FLIP'
; tetris.asm:260: error: Undefined symbol 'prep_piece_value'
; 260     33 4808_0000    	insn ST_JMP_INSN	#T_PIECE_FLIP,	prep_piece_value
; tetris.asm:261: error: Undefined symbol 'prep_piece_value'
; 261     34 4808_6300    	insn ST_JMP_INSN	#S_PIECE,	prep_piece_value
; tetris.asm:262: error: Undefined symbol 'S_PIECE_FLIP'
; tetris.asm:262: error: Undefined symbol 'prep_piece_value'
; 262     35 4808_0000    	insn ST_JMP_INSN	#S_PIECE_FLIP,	prep_piece_value
; tetris.asm:263: error: Undefined symbol 'prep_piece_value'
; 263     36 4808_3600    	insn ST_JMP_INSN	#Z_PIECE,	prep_piece_value
; tetris.asm:264: error: Undefined symbol 'Z_PIECE_FLIP'
; tetris.asm:264: error: Undefined symbol 'prep_piece_value'
; 264     37 4808_0000    	insn ST_JMP_INSN	#Z_PIECE_FLIP,	prep_piece_value
; tetris.asm:265: error: Undefined symbol 'prep_piece_value'
; 265     38 4808_7400    	insn ST_JMP_INSN	#J_PIECE,	prep_piece_value
; tetris.asm:266: error: Undefined symbol 'J_PIECE_FLIP'
; tetris.asm:266: error: Undefined symbol 'prep_piece_value'
; 266     39 4808_0000    	insn ST_JMP_INSN	#J_PIECE_FLIP,	prep_piece_value
; tetris.asm:267: error: Undefined symbol 'prep_piece_value'
; 267     3a 4808_4700    	insn ST_JMP_INSN	#L_PIECE,	prep_piece_value
; tetris.asm:268: error: Undefined symbol 'L_PIECE_FLIP'
; tetris.asm:268: error: Undefined symbol 'prep_piece_value'
; 268     3b 4808_0000    	insn ST_JMP_INSN	#L_PIECE_FLIP,	prep_piece_value
; 271     3c 4010_ff00    prep_piece_value	nop	0
; tetris.asm:271: error: Extra junk at end of line '0'
; 272                     
; 274     3d 0202_2844    	jo	prep_piece_rot,	prep_piece_hor
; tetris.asm:276: error: Undefined symbol 'st'
; tetris.asm:276: error: Missing second operand
; 276     3e 0800_0000    	st	st	prep_piece_value,	piece_stage+5
; tetris.asm:276: error: Extra junk at end of line 'prep_piece_value,	piece_stage+5'
; 277     3f 4980_f0a9    	andto	#0xF0,	piece_stage+5
; 278     40 4800_fc00    	st	#-4,	tmp
; tetris.asm:279: error: Unknown instruction 'prep_piece_loop_0a'
; 279                     	prep_piece_loop_0a	lsl	prep_piece_value
; tetris.asm:280: error: Undefined symbol 'prep_piece_loop_0a'
; 280     41 802a_0000    	incjne	tmp,	prep_piece_loop_0a
; tetris.asm:281: error: Undefined symbol 'prep_piece_value'
; 281     42 0800_00a7    	st	prep_piece_value,	piece_stage+3
; 282     43 4018_ff44    	jmp	prep_piece_ret
; 288     44 4018_ff00    prep_piece_ret	jmp	0
; 289                     
; 290                     ; Render board subroutine
; 291                     ;
; 292                     ; How:
; 293                     ; Render the gameboard from left to right, top to bottom, to give the most simple console output (avoids ANSI console cursor movement).
; 294                     ;
; 295                     ; LOOP A: Starts at top of the board and then switches to bottom half of the board. The gameboard ptr offset changes from 1 to 0. (or 2 -> 1 -> 0 if using a bigger game board)
; 296                     ; LOOP B: Work down the rows using a single byte bitmask, shifting it right each iteration.
; 297                     ; LOOP C: Work along the columns from 0 to 10, incrementing the gameboard ptr by 2 each iteration.
; 298                     ;         Decide whether to render a block or empty character by ANDing the gameboard ptr value with the current bitmask
; 299                     
; 300                     ; Temporary variables for internal use
; 301     45              render_board_mask	skip	1 ; The row bitmask for selecting the row to render
; 302     46              render_board_col	skip	1 ; The current column iteration loop counter.
; 303                     
; 305     47 4800_014c    	st	#(GAMEBOARD_STRIDE-1),	render_board_ptr	; Start the render_board_ptr with an offset of 1 to render the top half of the board.
; 306                     ; LOOP A
; 308     48 4880_904c    	addto	#gameboard,	render_board_ptr	; Adjust the render_board_ptr to point into the gameboard
; 309     49 4800_8045    	st	#%1000_0000,	render_board_mask	; Initialize the bitmask for testing the column byte for which row is set
; 310                     ; LOOP B
; 312     4a 4800_f646    	st	#(-GAMEBOARD_COLS),	render_board_col	; Prepare column loop counter
; 313                     ; LOOP C
; 315     4b 0800_4500    	st	render_board_mask,	tmp
; 316     4c 8180_0000    render_board_ptr	insn AND_INSN	tmp,	0	; Indirect AND, store result in tmp
; 319     4d 006a_004f    	jne	tmp,	render_board_print_a
; 320     4e d808_7e50    	insn OUTC_JMP_INSN	#EMPTY_CHAR,	render_board_print_b	; Print empty char and jump over the block char print
; 321     4f d800_2300    render_board_print_a	outc	#BLOCK_CHAR
; 323     50 4880_024c    	addto	#GAMEBOARD_STRIDE,	render_board_ptr	; Move onto next column byte
; 324     51 802a_464b    	incjne	render_board_col,	render_board_loop_c	; If we still have columns to render, continue LOOP C
; 325                     ; END LOOP C
; 326     52 48e0_144c    	rsbto	#GAMEBOARD_SIZE,	render_board_ptr	; Reset render_board_ptr to pre-loop state
; 329     53 d800_0d00    	outc	#CR_CHAR
; 330     54 d800_0a00    	outc	#LF_CHAR
; 331                     
; 334     55 820a_454a    	insn LSR_JCC_INSN	render_board_mask,	render_board_loop_b
; 335                     ; END LOOP B
; 338     56 48e0_914c    	rsbto	#(gameboard+1),	render_board_ptr
; 340     57 0069_4c48    	jge	render_board_ptr,	render_board_loop_a	; Otherwise continue LOOP A.
; 341                     ; END LOOP A
; 342     58 4018_ff00    render_board_ret	jmp	0		; Return from subroutine.
; 343                     
; 344                     ; line_clr
; 345                     ;
; 346                     ; Clears all full rows from the gameboard.
; 347                     ;
; 348                     ; How:
; 349                     ; 1. Call get_full_lines to generate a bitmask of all the complete rows
; 350                     ; 2. Call rem_bits on each column in the gameboard with a copy of the complete rows bitmask.
; 351                     ; 3. Copy the result back over the gameboard.
; 352                     ;
; 353     59              line_clr_i	skip	1	; We cannot use tmp as loop counter since we call subroutines which overwrite tmp.
; 356     5a 8408_7a71    	jsr	get_full_lines_ret,	get_full_lines
; 357                     
; 359     5b 006a_6f5e    	jne	get_full_lines_mask+0,	line_clr_do_remove
; 360     5c 006a_705e    	jne	get_full_lines_mask+1,	line_clr_do_remove
; 361     5d 4018_ff6e    	jmp	line_clr_ret	; Fastpath to returning from the subroutine
; 362                     
; 364                     
; 367     5e 4800_007d    	clr	rem_bits_value+0
; 368     5f 4800_007e    	clr	rem_bits_value+1
; 369                     
; 371     60 4800_f659    	st	#(-GAMEBOARD_COLS),	line_clr_i	; Prep the loop counter
; 372                     
; 374     61 4800_9065    	st	#gameboard,	line_clr_read_ptr_0
; 376                     
; 377                     ; Line clear loop. It will call rem_bits with the line clear mask and each column of the gameboard.
; 381     62 0800_6f7b    	st	get_full_lines_mask+0,	rem_bits_mask+0	; Prep mask +0
; 382     63 0800_707c    	st	get_full_lines_mask+1,	rem_bits_mask+1	; Prep mask +1
; 383                     
; 385     64 0820_6566    	insn INCTO_INSN	line_clr_read_ptr_0,	line_clr_read_ptr_1	; Prep ptr +1
; 387     65 8080_7d00    line_clr_read_ptr_0	add	rem_bits_value+0,	0	; Load +0
; 388     66 8080_7e00    line_clr_read_ptr_1	add	rem_bits_value+1,	0	; Load +1
; 389                     
; 391     67 8408_8f81    	jsr	rem_bits_ret,	rem_bits
; 392                     
; 394     68 0800_656a    	st	line_clr_read_ptr_0,	line_clr_write_ptr_0	; Prep ptr +0
; 395     69 0800_666b    	st	line_clr_read_ptr_1,	line_clr_write_ptr_1	; Prep ptr +1
; 397     6a 0800_7f00    line_clr_write_ptr_0	st	rem_bits_result+0,	0	; Store +0
; 398     6b 0800_8000    line_clr_write_ptr_1	st	rem_bits_result+1,	0	; Store +1
; 399                     
; 401     6c 4880_0265    	addto	#2,	line_clr_read_ptr_0	; Iterate ptr +0
; 402     6d 802a_5962    	incjne	line_clr_i,	line_clr_loop	; Loop
; 403     6e 4018_ff00    line_clr_ret	jmp	0		; Return from subroutine
; 404                     
; 405                     ; get_full_lines
; 406                     ;
; 407                     ; Generates a 2 byte, 16 bit bitmask indicating which rows in the gameboard are filled.
; 408                     ; This is the bitwise AND of all columns in the gameboard.
; 409                     ;
; 410     6f              get_full_lines_mask	skip	2
; 411                     
; 413     71 4800_f600    	st	#(-GAMEBOARD_COLS),	tmp
; 414     72 4800_ff6f    	st	#0xFF,	get_full_lines_mask+0
; 415     73 4800_ff70    	st	#0xFF,	get_full_lines_mask+1
; 416     74 4800_9076    	st	#gameboard,	get_full_lines_ptr_0
; 418     75 0820_7677    	insn INCTO_INSN	get_full_lines_ptr_0,	get_full_lines_ptr_1
; 419     76 8180_6f00    get_full_lines_ptr_0	insn AND_INSN	get_full_lines_mask+0,	0
; 420     77 8180_7000    get_full_lines_ptr_1	insn AND_INSN	get_full_lines_mask+1,	0
; 421     78 4880_0276    	addto	#2,	get_full_lines_ptr_0
; 422     79 802a_0075    	incjne	tmp,	get_full_lines_loop
; 423     7a 4018_ff00    get_full_lines_ret	jmp	0		; Return from subroutine
; 424                     
; 425                     ; rem_bits
; 426                     ;
; 427                     ; Remove the bits from rem_bits_value in the positions they are set in rem_bits_mask.
; 428                     ; For each bit removed, the more significant bits are shifted right to fill its place.
; 429                     ; The leftmost most significant bits are filled with zeroes.
; 430                     ;
; 431                     ; The output is placed in rem_bits_result.
; 432                     ; rem_bits_mask and rem_bits_value are zeroed as a result of this process.
; 433                     ;
; 434     7b              rem_bits_mask	skip	2
; 435     7d              rem_bits_value	skip	2
; 436     7f              rem_bits_result	skip	2
; 439     81 4800_007f    	clr	rem_bits_result+0
; 440     82 4800_0080    	clr	rem_bits_result+1
; 441     83 4800_f000    	st	#-16,	tmp	; Loop 16 times
; 443     84 0880_7b7b    	lsl	rem_bits_mask+0		; Logical shift left mask (0 -> bit 0)
; 444     85 0890_7c7c    	rol	rem_bits_mask+1		; (bit 15 -> carry)
; 445     86 0064_008a    	jcc	rem_bits_A		; GOTO A if carry clear
; 447     87 0880_7d7d    	lsl	rem_bits_value+0		; Logical shift left value (0 -> bit 0)
; 448     88 0890_7e7e    	rol	rem_bits_value+1		; The carry result is discarded.
; 449     89 4018_ff8e    	jmp	rem_bits_loop_end
; 451     8a 0880_7d7d    	lsl	rem_bits_value+0		; Logical shift left value (0 -> bit 0)
; 452     8b 0890_7e7e    	rol	rem_bits_value+1		; (bit 15 -> carry)
; 453     8c 0890_7f7f    	rol	rem_bits_result+0		; Rotate left to save the carry into result (carry -> bit 0)
; 454     8d 0890_8080    	rol	rem_bits_result+1		; Carry from rotating result is discarded.
; 455     8e 802a_0084    rem_bits_loop_end	incjne	tmp,	rem_bits_loop	; Loop
; 456     8f 4018_ff00    rem_bits_ret	jmp	0		; Return from subroutine
; 457                     
; 458                     
; 459                     
; 460                     ; Game board
; 461                     ;
; 462     90              gameboard	skip	GAMEBOARD_SIZE
; 463                     ;
; 464                     ; The gameboard is made up of bytes stacked vertically.
; 465                     ; There are two bytes end to end for each column, 10 colums wide.
; 466                     ; This makes a 16x10 game board, totalling 20 bytes.
; 467                     ; The lower, even index byte is at the bottom of the board. The higher, odd index byte is at the top.
; 468                     ; The less significant bits in each byte are towards the bottom of the board, the higher significant bits are towards the top.
; 469                     ;
; 470                     ; Ideally we would use three bytes per row to make a 24x10 gameboard in 30 bytes,
; 471                     ; but this increases both gameboard storage size and the code required to deal with it.
; 472                     ;
; 473                     ; Gameboard layout (byte.bit):
; 474                     ;
; 475                     ; 1.7 3.7 5.7 7.7 9.7 11.7 13.7 15.7 17.7 19.7
; 476                     ; 1.6 3.6 5.6 7.6 9.6 11.6 13.6 15.6 17.6 19.6
; 477                     ; 1.5 3.5 5.5 7.5 9.5 11.5 13.5 15.5 17.5 19.5
; 478                     ; 1.4 3.4 5.4 7.4 9.4 11.4 13.4 15.4 17.4 19.4
; 479                     ; 1.3 3.3 5.3 7.3 9.3 11.3 13.3 15.3 17.3 19.3
; 480                     ; 1.2 3.2 5.2 7.2 9.2 11.2 13.2 15.2 17.2 19.2
; 481                     ; 1.1 3.1 5.1 7.1 9.1 11.1 13.1 15.1 17.1 19.1
; 482                     ; 1.0 3.0 5.0 7.0 9.0 11.0 13.0 15.0 17.0 19.0
; 483                     ; 0.7 2.7 4.7 6.7 8.7 10.7 12.7 14.7 16.7 18.7
; 484                     ; 0.6 2.6 4.6 6.6 8.6 10.6 12.6 14.6 16.6 18.6
; 485                     ; 0.5 2.5 4.5 6.5 8.5 10.5 12.5 14.5 16.5 18.5
; 486                     ; 0.4 2.4 4.4 6.4 8.4 10.4 12.4 14.4 16.4 18.4
; 487                     ; 0.3 2.3 4.3 6.3 8.3 10.3 12.3 14.3 16.3 18.3
; 488                     ; 0.2 2.2 4.2 6.2 8.2 10.2 12.2 14.2 16.2 18.2
; 489                     ; 0.1 2.1 4.1 6.1 8.1 10.1 12.1 14.1 16.1 18.1
; 490                     ; 0.0 2.0 4.0 6.0 8.0 10.0 12.0 14.0 16.0 18.0
; 491                     
; 492                     
; 493                     ; Piece stage
; 494     a4              piece_stage	skip	PIECE_STAGE_SIZE
; 495                     ;
; 496                     ; Piece stage layout (byte.bit):
; 497                     ;
; 498                     ; 1.7 3.7 5.7 7.7
; 499                     ; 1.6 3.6 5.6 7.6
; 500                     ; 1.5 3.5 5.5 7.5
; 501                     ; 1.4 3.4 5.4 7.4
; 502                     ; 1.3 3.3 5.3 7.3
; 503                     ; 1.2 3.2 5.2 7.2
; 504                     ; 1.1 3.1 5.1 7.1
; 505                     ; 1.0 3.0 5.0 7.0
; 506                     ; 0.7 2.7 4.7 6.7
; 507                     ; 0.6 2.6 4.6 6.6
; 508                     ; 0.5 2.5 4.5 6.5
; 509                     ; 0.4 2.4 4.4 6.4
; 510                     ; 0.3 2.3 4.3 6.3
; 511                     ; 0.2 2.2 4.2 6.2
; 512                     ; 0.1 2.1 4.1 6.1
; 513                     ; 0.0 2.0 4.0 6.0
; 514                     
; 515                     ; Placeholder label to easily see how big the program is from the symbol table

; 28 errors detected in pass 2

; Symbol table:
; AND_INSN = 0x81800000
; A_CHAR = 0x41
; BAR_CHAR = 0x7c
; BLOCK_CHAR = 0x23
; B_CHAR = 0x42
; CR_CHAR = 0xd
; C_CHAR = 0x43
; D_CHAR = 0x44
; EMPTY_CHAR = 0x7e
; END_OF_PROGRAM = 0xac
; E_CHAR = 0x45
; F_CHAR = 0x46
; GAMEBOARD_COLS = 0xa
; GAMEBOARD_SIZE = 0x14
; GAMEBOARD_STRIDE = 0x2
; G_CHAR = 0x47
; H_CHAR = 0x48
; INCTO_INSN = 0x8200000
; I_CHAR = 0x49
; I_PIECE = 0xf0
; I_PIECE_FLIP = ???
; J_CHAR = 0x4a
; J_PIECE = 0x74
; J_PIECE_FLIP = ???
; K_CHAR = 0x4b
; LF_CHAR = 0xa
; LSR_JCC_INSN = 0x820a0000
; L_CHAR = 0x4c
; L_PIECE = 0x47
; L_PIECE_FLIP = ???
; M_CHAR = 0x4d
; N_CHAR = 0x4e
; OUTC_JMP_INSN = 0x98080000
; O_CHAR = 0x4f
; O_PIECE = 0x66
; O_PIECE_FLIP = ???
; PIECE_STAGE_SIZE = 0x8
; P_CHAR = 0x50
; Q_CHAR = 0x51
; R_CHAR = 0x52
; SPACE_CHAR = 0x20
; ST_JMP_INSN = 0x8080000
; S_CHAR = 0x53
; S_PIECE = 0x63
; S_PIECE_FLIP = ???
; T_CHAR = 0x54
; T_PIECE = 0x72
; T_PIECE_FLIP = ???
; U_CHAR = 0x55
; V_CHAR = 0x56
; W_CHAR = 0x57
; X_CHAR = 0x58
; Y_CHAR = 0x59
; ZERO_CHAR = 0x30
; Z_CHAR = 0x5a
; Z_PIECE = 0x36
; Z_PIECE_FLIP = ???
; current_piece = 0x3
; current_pose = 0x4
; current_x = 0x5
; current_y = 0x6
; exec = 0x1
; gameboard = 0x90
; get_full_lines = 0x71
; get_full_lines_loop = 0x75
; get_full_lines_mask = 0x6f
; get_full_lines_ptr_0 = 0x76
; get_full_lines_ptr_1 = 0x77
; get_full_lines_ret = 0x7a
; line_clr = 0x5a
; line_clr_do_remove = 0x5e
; line_clr_i = 0x59
; line_clr_loop = 0x62
; line_clr_read_ptr_0 = 0x65
; line_clr_read_ptr_1 = 0x66
; line_clr_ret = 0x6e
; line_clr_write_ptr_0 = 0x6a
; line_clr_write_ptr_1 = 0x6b
; lines_cleared = 0x2
; piece_stage = 0xa4
; prep_piece = 0x29
; prep_piece_hor = 0x44
; prep_piece_jmp = 0x2e
; prep_piece_loop_0a = ???
; prep_piece_number = 0x2d
; prep_piece_ret = 0x44
; prep_piece_rot = 0x28
; prep_piece_value = ???
; prep_piece_vert = 0x3e
; rem_bits = 0x81
; rem_bits_A = 0x8a
; rem_bits_loop = 0x84
; rem_bits_loop_end = 0x8e
; rem_bits_mask = 0x7b
; rem_bits_result = 0x7f
; rem_bits_ret = 0x8f
; rem_bits_value = 0x7d
; render_board = 0x47
; render_board_col = 0x46
; render_board_loop_a = 0x48
; render_board_loop_b = 0x4a
; render_board_loop_c = 0x4b
; render_board_mask = 0x45
; render_board_print_a = 0x4f
; render_board_print_b = 0x50
; render_board_ptr = 0x4c
; render_board_ret = 0x58
; run = 0x7
; st = ???
; tmp = 0x0

; Memory image:
00: c810ff00 4018ff07
07: 480002a3
08: 480002a1 4800229f 4800739d 4800029b 48000299 48000297 48000295 48000793
10: 48003f91 48000fa2 48001fa0 48003f9e 4800ff9c 48000f9a 48003f98 48007f96
18: 48000f94 4800fd92 4800ff90 84085847 d8000d00 d8000a00 84086e5a 84085847
20: d8000d00 d8000a00 84086e5a 84085847 d8000d00 d8000a00 d8002100 c810ff00
29: 0a002800 0a000000 08902d2d 48802e2d 4018ff00 48086600 48080000
30: 4808f000 48080000 48087200 48080000 48086300 48080000 48083600 48080000
38: 48087400 48080000 48084700 48080000 4010ff00 02022844 08000000 4980f0a9
40: 4800fc00 802a0000 080000a7 4018ff44 4018ff00
47: 4800014c
48: 4880904c 48008045 4800f646 08004500 81800000 006a004f d8087e50 d8002300
50: 4880024c 802a464b 48e0144c d8000d00 d8000a00 820a454a 48e0914c 00694c48
58: 4018ff00
5a: 84087a71 006a6f5e 006a705e 4018ff6e 4800007d 4800007e
60: 4800f659 48009065 08006f7b 0800707c 08206566 80807d00 80807e00 84088f81
68: 0800656a 0800666b 08007f00 08008000 48800265 802a5962 4018ff00
71: 4800f600 4800ff6f 4800ff70 48009076 08207677 81806f00 81807000
78: 48800276 802a0075 4018ff00
81: 4800007f 48000080 4800f000 08807b7b 08907c7c 0064008a 08807d7d
88: 08907e7e 4018ff8e 08807d7d 08907e7e 08907f7f 08908080 802a0084 4018ff00
