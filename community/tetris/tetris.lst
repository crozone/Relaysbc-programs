; Pass 1...

; 0 errors detected in pass 1

; Pass 2...
; 1                       ; Tetris implementation
; 2                       ; Ryan Crosby 2022
; 3                       ;
; 4                       ; Run from 0x01.
; 5                       ;
; 6                       ; Completed:
; 7                       ;
; 8                       ; * Gameboard format
; 9                       ; * Gameboard rendering to console
; 10                      ; * Line clearing
; 11                      ;
; 12                      ; ~120 instructions left to implement the rest of TODO.
; 13                      ;
; 14                      ; TODO:
; 15                      ;
; 16                      ;
; 17                      ; * Description with controls etc.
; 18                      ; * Smarter temporary variable management.
; 19                      ;       Define a small section of memory to use like a shared register pool.
; 20                      ;       Go through the subroutines and replace dedicated temporary variables with shared variables from the register pool that haven't been used yet in the execution flow.
; 21                      ;       Also inline most subroutines, most are called from a single spot.
; 22                      
; 23                      ;
; 24                      
; 25                      ; Constants
; 26                      ;
; 27                      
; 28      0000_0000       SPACE_CHAR	equ	0x20	; Space
; 29      0000_0000       BLOCK_CHAR	equ	0x23	; #
; 30      0000_0000       EMPTY_CHAR	equ	0x7E 	; ~
; 31      0000_0000       BAR_CHAR	equ	0x7C	; |
; 32                      
; 33      0000_0000       CR_CHAR	equ	0x0D	; Carriage Return CR \r
; 34      0000_0000       LF_CHAR	equ	0x0A	; Linefeed LF \n
; 35                      
; 36                      ; Number constants
; 37      0000_0000       ZERO_CHAR	equ	0x30	; 0
; 38                      
; 39                      ; Alphabet constants
; 40      0000_0000       A_CHAR	equ	0x41	; A
; 41      0000_0000       B_CHAR	equ	A_CHAR+1
; 42      0000_0000       C_CHAR	equ	A_CHAR+2
; 43      0000_0000       D_CHAR	equ	A_CHAR+3
; 44      0000_0000       E_CHAR	equ	A_CHAR+4
; 45      0000_0000       F_CHAR	equ	A_CHAR+5
; 46      0000_0000       G_CHAR	equ	A_CHAR+6
; 47      0000_0000       H_CHAR	equ	A_CHAR+7
; 48      0000_0000       I_CHAR	equ	A_CHAR+8
; 49      0000_0000       J_CHAR	equ	A_CHAR+9
; 50      0000_0000       K_CHAR	equ	A_CHAR+10
; 51      0000_0000       L_CHAR	equ	A_CHAR+11
; 52      0000_0000       M_CHAR	equ	A_CHAR+12
; 53      0000_0000       N_CHAR	equ	A_CHAR+13
; 54      0000_0000       O_CHAR	equ	A_CHAR+14
; 55      0000_0000       P_CHAR	equ	A_CHAR+15
; 56      0000_0000       Q_CHAR	equ	A_CHAR+16
; 57      0000_0000       R_CHAR	equ	A_CHAR+17
; 58      0000_0000       S_CHAR	equ	A_CHAR+18
; 59      0000_0000       T_CHAR	equ	A_CHAR+19
; 60      0000_0000       U_CHAR	equ	A_CHAR+20
; 61      0000_0000       V_CHAR	equ	A_CHAR+21
; 62      0000_0000       W_CHAR	equ	A_CHAR+22
; 63      0000_0000       X_CHAR	equ	A_CHAR+23
; 64      0000_0000       Y_CHAR	equ	A_CHAR+24
; 65      0000_0000       Z_CHAR	equ	A_CHAR+25
; 66                      
; 67                      ; Additional custom instructions
; 68                      ; To use these, call them like: insn INCTO_INSN aa, bb
; 69      0000_0000       AND_INSN	equ	0x81800000	; The WRA version of andto. ANDs [aa] and [bb], and stores in [aa].
; 70      0000_0000       INCTO_INSN	equ	0x08200000	; Stores [aa] + 1 --> [bb] in one instruction.
; 71                      
; 72                      ; Catch for any jumps to null (0x00). This usually indicates a subroutine hasn't had its return address set.
; 73                      ;
; 74                      ; Also used as a temporary storage register, and sometimes as the return value for subroutines that only need to return a status.
; 75                      
; 76      00              	org	0x00
; 77      00 c810_ff00    tmp	halt
; 78                      
; 79                      ; ENTRY POINT
; 80      01              	org	0x01
; 81      01 4018_ff07    exec	jmp	run	; Jump to start of program
; 82                      
; 83                      
; 84                      ; Pieces templates
; 85                      ;
; 86                      ; Piece patterns are stored as a single byte,	represening the piece in its starting/0 pose.
; 87                      ; The byte makes up two rows of 4 colums,	which is enough to fit every kind of piece lying "flat".
; 88                      ;
; 89                      ; Bits 0-3 are the bottom row,	bits 4-7 are the top row.
; 90                      ; The LSB of the row is the _leftmost_ square,	so pieces are rendered left to right LSB to RSB.
; 91                      ; This is the left to right mirror of the way that bits are normally written out
; 92                      ; left to right RSB to LSB,	so take care.
; 93                      ;
; 94                      
; 96                      
; 97                      ;; TODO: How do these actually get decoded/used?
; 98                      
; 99                      ; Real | Bits | Hex
; 100                     ;
; 101                     ; 1110 | 0111 | 7
; 102                     ; 0100 | 0010 | 2
; 103     0000_0002       t_piece	equ	0x72
; 104                     
; 105                     ; 0110 | 0110 | 6
; 106                     ; 1100 | 0011 | 3
; 107     0000_0002       s_piece	equ	0x63
; 108                     
; 109                     ; 1100 | 0011 | 3
; 110                     ; 0110 | 0110 | 6
; 111     0000_0002       z_piece	equ	0x36
; 112                     
; 113                     ; 0010 | 0100 | 4
; 114                     ; 1110 | 0111 | 7
; 115     0000_0002       l_piece	equ	0x47
; 116                     
; 117                     ; 1110 | 0111 | 7
; 118                     ; 0010 | 0100 | 4
; 119     0000_0002       j_piece	equ	0x74
; 120                     
; 121                     ; 0110 | 0110 | 6
; 122                     ; 0110 | 0110 | 6
; 123     0000_0002       o_piece	equ	0x66
; 124                     
; 125                     ; 1111 | 1111 | F
; 126                     ; 0000 | 0000 | 0
; 127     0000_0002       i_piece	equ	0xF0
; 128                     
; 129                     
; 130                     
; 131                     ; Game state
; 132                     ;
; 133     02              lines_cleared	skip	1
; 134                     
; 135     03              current_piece	skip	1
; 136     04              current_pose	skip	1
; 137     05              current_x	skip	1
; 138     06              current_y	skip	1
; 139                     
; 140                     
; 141                     
; 142                     ; Start of application code
; 143                     ;
; 148     07 4800_ff83    	st	#%1111_1111,	gameboard+19
; 149     08 4800_f181    	st	#%1111_0001,	gameboard+17
; 150     09 4800_f97f    	st	#%1111_1001,	gameboard+15
; 151     0a 4800_fd7d    	st	#%1111_1101,	gameboard+13
; 152     0b 4800_ff7b    	st	#%1111_1111,	gameboard+11
; 153     0c 4800_ff79    	st	#%1111_1111,	gameboard+9
; 154     0d 4800_fd77    	st	#%1111_1101,	gameboard+7
; 155     0e 4800_f975    	st	#%1111_1001,	gameboard+5
; 156     0f 4800_f173    	st	#%1111_0001,	gameboard+3
; 157     10 4800_ff71    	st	#%1111_1111,	gameboard+1
; 159     11 4800_0f82    	st	#%0000_1111,	gameboard+18
; 160     12 4800_1f80    	st	#%0001_1111,	gameboard+16
; 161     13 4800_3f7e    	st	#%0011_1111,	gameboard+14
; 162     14 4800_7e7c    	st	#%0111_1110,	gameboard+12
; 163     15 4800_fc7a    	st	#%1111_1100,	gameboard+10
; 164     16 4800_fc78    	st	#%1111_1100,	gameboard+8
; 165     17 4800_7e76    	st	#%0111_1110,	gameboard+6
; 166     18 4800_3f74    	st	#%0011_1111,	gameboard+4
; 167     19 4800_1f72    	st	#%0001_1111,	gameboard+2
; 168     1a 4800_0f70    	st	#%0000_1111,	gameboard+0
; 171     1b 8408_3b27    	jsr	render_board_ret,	render_board
; 173     1c d800_0d00    	outc	#CR_CHAR
; 174     1d d800_0a00    	outc	#LF_CHAR
; 177     1e 8408_4e3d    	jsr	line_clr_ret,	line_clr
; 180     1f 8408_3b27    	jsr	render_board_ret,	render_board
; 182     20 d800_0d00    	outc	#CR_CHAR
; 183     21 d800_0a00    	outc	#LF_CHAR
; 186     22 d800_2100    	outc	#33	; !
; 187     23 c810_ff00    	halt
; 188                     
; 189                     ; Render board subroutine
; 190                     ;
; 191                     ; How:
; 192                     ; Render the gameboard from left to right, top to bottom, to give the most simple console output (avoids ANSI console cursor movement).
; 193                     ;
; 194                     ; LOOP A: Starts at top of the board and then switches to bottom half of the board. The gameboard ptr offset changes from 1 to 0.
; 195                     ; LOOP B: Work down the rows using a single byte bitmask, shifting it right each iteration.
; 196                     ; LOOP C: Work along the columns from 0 to 10, incrementing the gameboard ptr by 2 each iteration.
; 197                     ;         Decide whether to render a block or empty character by ANDing the gameboard ptr value with the current bitmask
; 198                     
; 199                     ; Temporary variables for internal use
; 200     24              render_board_top	skip	1 ; boolean to select top or bottom of the board. 1 for top, 0 for bottom.
; 201     25              render_board_mask	skip	1 ; The row mask for selecting the row to render
; 202     26              render_board_col	skip	1 ; The current column iteration. -10 -> 0 (to allow for increment and jump if not zero)
; 203                     
; 205     27 4800_0124    	st	#1,	render_board_top
; 207     28 4800_8025    	st	#%1000_0000,	render_board_mask
; 209     29 4800_702d    	st	#gameboard,	render_board_ptr
; 210     2a 0880_242d    	addto	render_board_top,	render_board_ptr	; Offset the gameboard ptr by 1 if we're rendering the top half
; 211     2b 4800_f626    	st	#-10,	render_board_col	; Prepare column loop counter
; 213     2c 4800_0000    	clr	tmp
; 214     2d 8080_0000    render_board_ptr	add	tmp,	0	; Load
; 216     2e 0980_2500    	andto	render_board_mask,	tmp
; 219     2f 006a_0032    	jne	tmp,	render_board_print_a
; 220     30 d800_7e00    	outc	#EMPTY_CHAR
; 221     31 4018_ff33    	jmp	render_board_print_b
; 222     32 d800_2300    render_board_print_a	outc	#BLOCK_CHAR
; 224     33 4880_022d    	addto	#2,	render_board_ptr	; Move onto next column byte
; 225     34 802a_262c    	incjne	render_board_col,	render_board_loop_c	; Row render loop
; 228     35 d800_0d00    	outc	#CR_CHAR
; 229     36 d800_0a00    	outc	#LF_CHAR
; 230                     
; 231     37 0a00_2525    	lsr	render_board_mask		; Logical shift right (0 into top spot). This moves down a row.
; 232     38 0064_0029    	jcc	render_board_loop_b		; Loop if we haven't shifted all the way out yet
; 236     39 48e0_0124    	dec	render_board_top
; 237     3a 0062_2428    	jeq	render_board_top,	render_board_loop_a	; Move onto bottom half of board
; 238                     
; 239     3b 4018_ff00    render_board_ret	jmp	0		; Return from subroutine.
; 240                     
; 241                     ; line_clr
; 242                     ;
; 243                     ; Clears all full rows from the gameboard.
; 244                     ;
; 245                     ; How:
; 246                     ; 1. Call get_full_lines to generate a bitmask of all the complete rows
; 247                     ; 2. Call rem_bits on each column in the gameboard with a copy of the complete rows bitmask.
; 248                     ; 3. Copy the result back over the gameboard.
; 249                     ;
; 250     3c              line_clr_i	skip	1	; We cannot use tmp as loop counter since we call subroutines which overwrite tmp.
; 251                     
; 254     3d 4800_005d    	clr	rem_bits_value+0
; 255     3e 4800_005e    	clr	rem_bits_value+1
; 256                     
; 258     3f 8408_5a51    	jsr	get_full_lines_ret,	get_full_lines
; 261                     
; 263     40 4800_f63c    	st	#-10,	line_clr_i	; Prep the loop counter
; 264                     
; 267     41 4800_6e46    	st	#gameboard-2,	line_clr_read_ptr_0
; 269                     
; 270                     ; Line clear loop. It will call rem_bits with the line clear mask and each column of the gameboard.
; 274     42 0800_4f5b    	st	get_full_lines_mask+0,	rem_bits_mask+0
; 275     43 0800_505c    	st	get_full_lines_mask+1,	rem_bits_mask+1
; 276                     
; 279     44 4880_0246    	addto	#2,	line_clr_read_ptr_0	; Prep ptr +0
; 280     45 0820_4647    	insn INCTO_INSN	line_clr_read_ptr_0,	line_clr_read_ptr_1	; Prep ptr +1
; 285     46 8080_5d00    line_clr_read_ptr_0	add	rem_bits_value+0,	0	; Load +0
; 286     47 8080_5e00    line_clr_read_ptr_1	add	rem_bits_value+1,	0	; Load +1
; 289     48 8408_6f61    	jsr	rem_bits_ret,	rem_bits
; 292     49 0800_464b    	st	line_clr_read_ptr_0,	line_clr_write_ptr_0
; 293     4a 0800_474c    	st	line_clr_read_ptr_1,	line_clr_write_ptr_1
; 295     4b 0800_5f00    line_clr_write_ptr_0	st	rem_bits_result+0,	0
; 296     4c 0800_6000    line_clr_write_ptr_1	st	rem_bits_result+1,	0
; 297                     
; 298     4d 802a_3c42    	incjne	line_clr_i,	line_clr_loop	; Loop
; 299     4e 4018_ff00    line_clr_ret	jmp	0		; Return from subroutine
; 300                     
; 301                     ; get_full_lines
; 302                     ;
; 303                     ; Generates a 2 byte, 16 bit bitmask indicating which rows in the gameboard are filled.
; 304                     ; This is the bitwise AND of all columns in the gameboard.
; 305                     ;
; 306     4f              get_full_lines_mask	skip	2
; 307                     
; 309     51 4800_f600    	st	#-10,	tmp
; 310     52 4800_ff4f    	st	#0xFF,	get_full_lines_mask+0
; 311     53 4800_ff50    	st	#0xFF,	get_full_lines_mask+1
; 312     54 4800_6e57    	st	#gameboard-2,	get_full_lines_ptr_0
; 314     55 4880_0257    	addto	#2,	get_full_lines_ptr_0
; 315     56 0820_5758    	insn INCTO_INSN	get_full_lines_ptr_0,	get_full_lines_ptr_1
; 316     57 8180_4f00    get_full_lines_ptr_0	insn AND_INSN	get_full_lines_mask+0,	0
; 317     58 8180_5000    get_full_lines_ptr_1	insn AND_INSN	get_full_lines_mask+1,	0
; 319     59 802a_0055    	incjne	tmp,	get_full_lines_loop
; 320     5a 4018_ff00    get_full_lines_ret	jmp	0		; Return from subroutine
; 321                     
; 322                     ; rem_bits
; 323                     ;
; 324                     ; Remove the bits from rem_bits_value in the positions they are set in rem_bits_mask.
; 325                     ; For each bit removed, the more significant bits are shifted right to fill its place.
; 326                     ; The leftmost most significant bits are filled with zeroes.
; 327                     ;
; 328                     ; The output is placed in rem_bits_result.
; 329                     ; rem_bits_mask and rem_bits_value are zeroed as a result of the process.
; 330                     ;
; 331     5b              rem_bits_mask	skip	2
; 332     5d              rem_bits_value	skip	2
; 333     5f              rem_bits_result	skip	2
; 336     61 4800_005f    	clr	rem_bits_result+0
; 337     62 4800_0060    	clr	rem_bits_result+1
; 338                     
; 339     63 4800_f000    	st	#-16,	tmp	; Loop 16 times
; 341     64 0880_5b5b    	lsl	rem_bits_mask+0		; Logical shift left mask (0 -> bit 0)
; 342     65 0890_5c5c    	rol	rem_bits_mask+1		; (bit 15 -> carry)
; 343     66 0064_006a    	jcc	rem_bits_A		; GOTO A if carry clear
; 345     67 0880_5d5d    	lsl	rem_bits_value+0		; Logical shift left value (0 -> bit 0)
; 346     68 0890_5e5e    	rol	rem_bits_value+1		; The carry result is discarded.
; 347     69 4018_ff6e    	jmp	rem_bits_loop_end
; 349     6a 0880_5d5d    	lsl	rem_bits_value+0		; Logical shift left value (0 -> bit 0)
; 350     6b 0890_5e5e    	rol	rem_bits_value+1		; (bit 15 -> carry)
; 351     6c 0890_5f5f    	rol	rem_bits_result+0		; Rotate left to save the carry into result (carry -> bit 0)
; 352     6d 0890_6060    	rol	rem_bits_result+1		; Carry from rotating result is discarded.
; 353     6e 802a_0064    rem_bits_loop_end	incjne	tmp,	rem_bits_loop	; Loop
; 354     6f 4018_ff00    rem_bits_ret	jmp	0		; Return from subroutine
; 355                     
; 356                     
; 357                     
; 358                     ; Game board
; 359                     ;
; 360     70              gameboard	skip	20
; 361                     ;
; 362                     ; The gameboard is made up of bytes stacked vertically.
; 363                     ; There are two bytes end to end for each column, 10 colums wide.
; 364                     ; This makes a 16x10 game board, totalling 20 bytes.
; 365                     ; The lower, even index byte is at the bottom of the board. The higher, odd index byte is at the top.
; 366                     ; The less significant bits in each byte are towards the bottom of the board, the higher significant bits are towards the top.
; 367                     ;
; 368                     ; Ideally we would use three bytes per row to make a 24x10 gameboard in 30 bytes,
; 369                     ; but this increases both gameboard storage size and the code required to deal with it.
; 370                     ;
; 371                     ; Gameboard layout (byte.bit):
; 372                     ;
; 373                     ; 1.7 3.7 5.7 7.7 9.7 11.7 13.7 15.7 17.7 19.7
; 374                     ; 1.6 3.6 5.6 7.6 9.6 11.6 13.6 15.6 17.6 19.6
; 375                     ; 1.5 3.5 5.5 7.5 9.5 11.5 13.5 15.5 17.5 19.5
; 376                     ; 1.4 3.4 5.4 7.4 9.4 11.4 13.4 15.4 17.4 19.4
; 377                     ; 1.3 3.3 5.3 7.3 9.3 11.3 13.3 15.3 17.3 19.3
; 378                     ; 1.2 3.2 5.2 7.2 9.2 11.2 13.2 15.2 17.2 19.2
; 379                     ; 1.1 3.1 5.1 7.1 9.1 11.1 13.1 15.1 17.1 19.1
; 380                     ; 1.0 3.0 5.0 7.0 9.0 11.0 13.0 15.0 17.0 19.0
; 381                     ; 0.7 2.7 4.7 6.7 8.7 10.7 12.7 14.7 16.7 18.7
; 382                     ; 0.6 2.6 4.6 6.6 8.6 10.6 12.6 14.6 16.6 18.6
; 383                     ; 0.5 2.5 4.5 6.5 8.5 10.5 12.5 14.5 16.5 18.5
; 384                     ; 0.4 2.4 4.4 6.4 8.4 10.4 12.4 14.4 16.4 18.4
; 385                     ; 0.3 2.3 4.3 6.3 8.3 10.3 12.3 14.3 16.3 18.3
; 386                     ; 0.2 2.2 4.2 6.2 8.2 10.2 12.2 14.2 16.2 18.2
; 387                     ; 0.1 2.1 4.1 6.1 8.1 10.1 12.1 14.1 16.1 18.1
; 388                     ; 0.0 2.0 4.0 6.0 8.0 10.0 12.0 14.0 16.0 18.0
; 389                     
; 390                     
; 391                     ; New piece stage
; 392                     ; TODO
; 393                     
; 394                     ; Placeholder label to easily see how big the program is from the symbol table

; 0 errors detected in pass 2

; Symbol table:
; AND_INSN = 0x81800000
; A_CHAR = 0x41
; BAR_CHAR = 0x7c
; BLOCK_CHAR = 0x23
; B_CHAR = 0x42
; CR_CHAR = 0xd
; C_CHAR = 0x43
; D_CHAR = 0x44
; EMPTY_CHAR = 0x7e
; END_OF_PROGRAM = 0x84
; E_CHAR = 0x45
; F_CHAR = 0x46
; G_CHAR = 0x47
; H_CHAR = 0x48
; INCTO_INSN = 0x8200000
; I_CHAR = 0x49
; J_CHAR = 0x4a
; K_CHAR = 0x4b
; LF_CHAR = 0xa
; L_CHAR = 0x4c
; M_CHAR = 0x4d
; N_CHAR = 0x4e
; O_CHAR = 0x4f
; P_CHAR = 0x50
; Q_CHAR = 0x51
; R_CHAR = 0x52
; SPACE_CHAR = 0x20
; S_CHAR = 0x53
; T_CHAR = 0x54
; U_CHAR = 0x55
; V_CHAR = 0x56
; W_CHAR = 0x57
; X_CHAR = 0x58
; Y_CHAR = 0x59
; ZERO_CHAR = 0x30
; Z_CHAR = 0x5a
; current_piece = 0x3
; current_pose = 0x4
; current_x = 0x5
; current_y = 0x6
; exec = 0x1
; gameboard = 0x70
; get_full_lines = 0x51
; get_full_lines_loop = 0x55
; get_full_lines_mask = 0x4f
; get_full_lines_ptr_0 = 0x57
; get_full_lines_ptr_1 = 0x58
; get_full_lines_ret = 0x5a
; i_piece = 0xf0
; j_piece = 0x74
; l_piece = 0x47
; line_clr = 0x3d
; line_clr_i = 0x3c
; line_clr_loop = 0x42
; line_clr_read_ptr_0 = 0x46
; line_clr_read_ptr_1 = 0x47
; line_clr_ret = 0x4e
; line_clr_write_ptr_0 = 0x4b
; line_clr_write_ptr_1 = 0x4c
; lines_cleared = 0x2
; o_piece = 0x66
; pieces_arr = 0x2
; rem_bits = 0x61
; rem_bits_A = 0x6a
; rem_bits_loop = 0x64
; rem_bits_loop_end = 0x6e
; rem_bits_mask = 0x5b
; rem_bits_result = 0x5f
; rem_bits_ret = 0x6f
; rem_bits_value = 0x5d
; render_board = 0x27
; render_board_col = 0x26
; render_board_loop_a = 0x28
; render_board_loop_b = 0x29
; render_board_loop_c = 0x2c
; render_board_mask = 0x25
; render_board_print_a = 0x32
; render_board_print_b = 0x33
; render_board_ptr = 0x2d
; render_board_ret = 0x3b
; render_board_top = 0x24
; run = 0x7
; s_piece = 0x63
; t_piece = 0x72
; tmp = 0x0
; z_piece = 0x36

; Memory image:
00: c810ff00 4018ff07
07: 4800ff83
08: 4800f181 4800f97f 4800fd7d 4800ff7b 4800ff79 4800fd77 4800f975 4800f173
10: 4800ff71 48000f82 48001f80 48003f7e 48007e7c 4800fc7a 4800fc78 48007e76
18: 48003f74 48001f72 48000f70 84083b27 d8000d00 d8000a00 84084e3d 84083b27
20: d8000d00 d8000a00 d8002100 c810ff00
27: 48000124
28: 48008025 4800702d 0880242d 4800f626 48000000 80800000 09802500 006a0032
30: d8007e00 4018ff33 d8002300 4880022d 802a262c d8000d00 d8000a00 0a002525
38: 00640029 48e00124 00622428 4018ff00
3d: 4800005d 4800005e 84085a51
40: 4800f63c 48006e46 08004f5b 0800505c 48800246 08204647 80805d00 80805e00
48: 84086f61 0800464b 0800474c 08005f00 08006000 802a3c42 4018ff00
51: 4800f600 4800ff4f 4800ff50 48006e57 48800257 08205758 81804f00
58: 81805000 802a0055 4018ff00
61: 4800005f 48000060 4800f000 08805b5b 08905c5c 0064006a 08805d5d
68: 08905e5e 4018ff6e 08805d5d 08905e5e 08905f5f 08906060 802a0064 4018ff00
