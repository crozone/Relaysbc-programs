; Pass 1...

; 0 errors detected in pass 1

; Pass 2...
; 1                       ; Tetris implementation
; 2                       ; Ryan Crosby 2021
; 3                       ;
; 4                       ; Run from 0x01.
; 5                       ;
; 6                       ; TODO: Description with controls etc.
; 7                       ;
; 8                       
; 9                       ; Catch for any indirect jumps to null (0x00).
; 10                      ; Also serves as a temporary register or discard register for data.
; 11                      ; Treat 0x00 like a register. It can be used anywhere so don't expect it to survive a subroutine.
; 12                      ;
; 13      00              	org	0x00
; 14      00 c810_ff00    tmp	halt
; 15                      
; 16                      ; ENTRY POINT
; 17      01              	org	0x01
; 18      01 4018_ff45    exec	jmp	run	; Jump to start of program
; 19                      
; 20                      ; Constants
; 21                      ;
; 22      02 c810_ff23    block_char	data	0x23	; #
; 23      03 c810_ff20    empty_char	data	0x20	; Space
; 24      04 c810_ff0d    newline	data	0x0D	; Carriage Return CR \r
; 25      05 c810_ff0a    	data	0x0A	; Linefeed LF \n
; 26                      
; 27                      ; Pieces templates
; 28                      ;
; 29                      ; Piece patterns are stored as a single byte,	represening the piece in its starting/0 pose.
; 30                      ; The byte makes up two rows of 4 colums,	which is enough to fit every kind of piece lying "flat".
; 31                      ;
; 32                      ; Bits 0-3 are the bottom row,	bits 4-7 are the top row.
; 33                      ; The LSB of the row is the _leftmost_ square,	so pieces are rendered left to right LSB to RSB.
; 34                      ; This is the left to right mirror of the way that bits are normally written out
; 35                      ; left to right RSB to LSB,	so take care.
; 36                      ;
; 37                      
; 39                      
; 40                      ; Real | Bits | Hex
; 41                      ;
; 42                      ; 1110 | 0111 | 7
; 43                      ; 0100 | 0010 | 2
; 44      06 c810_ff72    t_piece	data	0x72
; 45                      
; 46                      ; 0110 | 0110 | 6
; 47                      ; 1100 | 0011 | 3
; 48      07 c810_ff63    s_piece	data	0x63
; 49                      
; 50                      ; 1100 | 0011 | 3
; 51                      ; 0110 | 0110 | 6
; 52      08 c810_ff36    z_piece	data	0x36
; 53                      
; 54                      ; 0010 | 0100 | 4
; 55                      ; 1110 | 0111 | 7
; 56      09 c810_ff47    l_piece	data	0x47
; 57                      
; 58                      ; 1110 | 0111 | 7
; 59                      ; 0010 | 0100 | 4
; 60      0a c810_ff74    j_piece	data	0x74
; 61                      
; 62                      ; 0110 | 0110 | 6
; 63                      ; 0110 | 0110 | 6
; 64      0b c810_ff66    o_piece	data	0x66
; 65                      
; 66                      ; 1111 | 1111 | F
; 67                      ; 0000 | 0000 | 0
; 68      0c c810_fff0    i_piece	data	0xF0
; 69                      
; 70                      
; 71                      
; 72                      ; Game state - TODO: Put this at the end of memory,	> 127,	to save EEPROM programmable space.
; 73                      ;
; 74      0d              current_cleared	skip	1
; 75                      
; 76      0e              current_piece	skip	1
; 77      0f              current_pose	skip	1
; 78      10              current_x	skip	1
; 79      11              current_y	skip	1
; 80                      
; 81                      ; GAME BOARD
; 82                      ;
; 83                      ; Left of board is X = 0; right is X = 9
; 84                      ; Bottom of board is Y = 0, top is Y = 19
; 85                      ;
; 86                      ; The game board is made up of 20 rows, of 10 columns each.
; 87                      ; Each row is represented by two bytes (16 bits) - 6 bits are wasted on the odd bytes.
; 88                      ; The left of the board is the LSB of the lower byte,	the right of the board is the 2nd bit of the upper byte.
; 89                      ; The lowermost row is row Y=0, and is represented by bytes 0 (left) and 1 (right).
; 90                      ; The uppermost row is row Y=19, and is represented by bytes 38 (left) and 39 (right). 
; 91                      ;
; 92                      ; BOARD LAYOUT:
; 93                      ;
; 94                      ; Row Y=3 : Byte 6 --> [ 01234567 | 89 XXXXXX ] <-- Byte 7
; 95                      ; Row Y=2 : Byte 4 --> [ 01234567 | 89 XXXXXX ] <-- Byte 5
; 96                      ; Row Y=1 : Byte 2 --> [ 01234567 | 89 XXXXXX ] <-- Byte 3
; 97                      ; Row Y=0 : Byte 0 --> [ 01234567 | 89 XXXXXX ] <-- Byte 1
; 98                      ;
; 99                      ; ROW LAYOUT:
; 100                     ;
; 101                     ;	LEFT            RIGHT
; 102                     ; X:	0 1 2 3 4 5 6 7   8 9
; 103                     ;	- - - - - - - -   - -
; 104                     ; Bit:	0 1 2 3 4 5 6 7 | 0 1
; 105                     ;	^ LSB     MSB ^ | ^ LSB
; 106                     ; Byte:	0               | 1
; 107                     ;
; 108     12 c810_ffff    	data	0xFF ; Provide a solid boarder "below" the gameboard, at Y=-1.
; 109     13 c810_ffff    	data	0xFF ; This simplifies collision detection.
; 110     14              gameboard	skip	40
; 111                     
; 112                     
; 113                     ; Piece staging buffer.
; 114                     ; This buffer contains the current piece in the selected pose, in the same format as the game board.
; 115                     ; It is 4 rows high, each row is 2 bytes, just like the game board.
; 116                     ; This allows easy left/right movement of the piece (simple bitwise rotation of each row left or right),
; 117                     ; and easy updating of, or collision checking with, the game board (with bitwise operations).
; 118     3c              piece_stage	skip	8
; 119                     
; 120                     ; Start of application code
; 121                     ;
; 122     44              test_loop_i	skip	1
; 126                     
; 131                     
; 132     45 4800_000e    	st	#0,	current_piece	; TODO: Randomize
; 133     46 4800_000f    	st	#0,	current_pose	; Initial piece pose = 0
; 134     47 4800_0010    	st	#0,	current_x
; 135     48 4800_1011    	st	#16,	current_y	; Initial piece position in top of board (20 - 4)
; 136                     
; 137     49 4800_fa44    	st	#-6,	test_loop_i
; 139     4a 4880_010e    	inc	current_piece
; 140                     
; 141     4b 8408_927d    	jsr	prep_piece_ret,	prep_piece
; 142                     
; 143     4c 4800_3c93    	st	#piece_stage,	render_ptr
; 144     4d 4800_0094    	st	#0,	render_row
; 145     4e 4800_0495    	st	#4,	render_rows
; 146     4f 4800_0096    	st	#0,	render_col
; 147     50 4800_0a97    	st	#10,	render_cols
; 148                     
; 149     51 4800_0462    	st	#4,	shift_stage_n	; Initial piece position in middle of board (10/2 - 3/2)
; 150     52 8408_7a63    	jsr	shift_stage_ret,	shift_stage
; 151                     
; 152     53 8408_b99c    	jsr	render_ret,	render
; 153                     
; 154     54 4800_0262    	st	#2,	shift_stage_n
; 155     55 8408_7a63    	jsr	shift_stage_ret,	shift_stage
; 156                     
; 157     56 8408_b99c    	jsr	render_ret,	render
; 158                     
; 159     57 4800_fa62    	st	#-6,	shift_stage_n
; 160     58 8408_7a63    	jsr	shift_stage_ret,	shift_stage
; 161                     
; 162     59 8408_b99c    	jsr	render_ret,	render
; 163                     
; 164     5a 802a_444a    	incjne	test_loop_i,	test_loop
; 165                     
; 166     5b 9800_0400    	outc	newline+0
; 167     5c 9800_0500    	outc	newline+1
; 168     5d d800_4800    	outc	#0x48		; H
; 169     5e d800_4100    	outc	#0x41		; A
; 170     5f d800_4c00    	outc	#0x4C		; L
; 171     60 d800_5400    	outc	#0x54		; T
; 172                     
; 173     61 c810_ff00    	halt
; 174                     
; 175                     ; TODO
; 176                     ; Subroutine that gets the OR'd value of the piece stage and the game board(+ row)
; 177                     ; This is for rendering the piece, overlayed on the game board.
; 178                     
; 179                     ; TODO
; 180                     ; Subroutine that checks for a collision (AND) between the piece stage and the game board(+ row)
; 181                     
; 182                     
; 183                     
; 184                     ; Shift piece stage by a given number of columns
; 185                     ; +ve column value = to the right of the gameboard = left shifting bits towards MSB
; 186                     ; -ve column value = to the left of the gameboard = right shifting bits towards LSB
; 187                     
; 188     62              shift_stage_n	skip	1
; 190     63 0880_6210    	addto	shift_stage_n,	current_x	; Adjust current piece position	
; 191                     
; 192     64 0800_6200    	st	shift_stage_n,	tmp
; 193     65 0069_0070    	jge	tmp,	ss_right
; 195     66 0a00_3d3d    	lsr	piece_stage+1		; 0 -> bit 7. Bit 0 -> C
; 196     67 0a10_3c3c    	ror	piece_stage+0		; C -> bit 7. Bit 0 -> C
; 197     68 0a00_3f3f    	lsr	piece_stage+3		; 0 -> bit 7. Bit 0 -> C
; 198     69 0a10_3e3e    	ror	piece_stage+2		; C -> bit 7. Bit 0 -> C
; 199     6a 0a00_4141    	lsr	piece_stage+5		; 0 -> bit 7. Bit 0 -> C
; 200     6b 0a10_4040    	ror	piece_stage+4		; C -> bit 7. Bit 0 -> C
; 201     6c 0a00_4343    	lsr	piece_stage+7		; 0 -> bit 7. Bit 0 -> C
; 202     6d 0a10_4242    	ror	piece_stage+6		; C -> bit 7. Bit 0 -> C
; 203                     
; 204     6e 802a_0066    	incjne	tmp,	ss_left
; 205                     
; 206     6f 4018_ff7a    	jmp	shift_stage_ret
; 208     70 0860_0000    	neg	tmp
; 210     71 0880_3c3c    	lsl	piece_stage+0		; 0 -> bit 0. Bit 7 -> C
; 211     72 0890_3d3d    	rol	piece_stage+1		; C -> bit 0. Bit 7 -> C
; 212     73 0880_3e3e    	lsl	piece_stage+2		; 0 -> bit 0. Bit 7 -> C
; 213     74 0890_3f3f    	rol	piece_stage+3		; C -> bit 0. Bit 7 -> C
; 214     75 0880_4040    	lsl	piece_stage+4		; 0 -> bit 0. Bit 7 -> C
; 215     76 0890_4141    	rol	piece_stage+5		; C -> bit 0. Bit 7 -> C
; 216     77 0880_4242    	lsl	piece_stage+6		; 0 -> bit 0. Bit 7 -> C
; 217     78 0890_4343    	rol	piece_stage+7		; C -> bit 0. Bit 7 -> C
; 218                     
; 219     79 802a_0071    	incjne	tmp,	ss_right_loop
; 220                     
; 221     7a 4018_ff00    shift_stage_ret	jmp	0
; 222                     
; 223                     
; 224                     
; 225                     ; Prepare piece buffer
; 226                     ; This function takes a piece number and a pose, and writes it to a buffer as 8 separate bytes,
; 227                     ; which is in the same layout as the piece board.
; 228                     ;
; 229                     ; The piece is written to position (0,0), which is the bottom leftmost corner of the buffer.
; 230                     ;
; 231                     ; This uses current_piece and current_pose.
; 232                     
; 233                     ; Private
; 234     7b              template_cpy	skip	1
; 235     7c              pp_tmp	skip	1
; 238     7d 4800_0680    	st	#pieces_arr,	template_ptr
; 239     7e 0880_0e80    	addto	current_piece,	template_ptr
; 240                     
; 242     7f 4800_007b    	clr	template_cpy
; 243     80 8080_7b00    template_ptr	add	template_cpy,	0
; 244                     
; 246     81 4800_3cba    	st	#piece_stage,	clrbuf_ptr
; 247     82 4800_08bb    	st	#8,	clrbuf_len
; 248     83 8408_c1bc    	jsr	clrbuf_ret,	clrbuf
; 249                     
; 253                     
; 254     84 4800_04c3    	st	#4,	rshift_n	; Prepare right shift function to do 4 right shifts.
; 255                     
; 257     85 0860_0f7c    	negto	current_pose,	pp_tmp
; 258                     
; 259     86 006a_7c8c    pp_case_0	jne	pp_tmp,	pp_case_1
; 260                     
; 262     87 0800_7b3c    	st	template_cpy,	piece_stage
; 263     88 4980_0f3c    	andto	#0x0F,	piece_stage
; 265     89 0800_7bc2    	st	template_cpy,	rshift_val
; 266     8a 8408_c7c4    	jsr	rshift_ret,	rshift
; 267     8b 0800_c23e    	st	rshift_val,	piece_stage+2	; Next row up
; 268                     
; 269     8c 802a_7c8e    pp_case_1	incjne	pp_tmp,	pp_case_2
; 270     8d 4018_ff00    	jmp	0		; HALT
; 271     8e 802a_7c90    pp_case_2	incjne	pp_tmp,	pp_case_3
; 272     8f 4018_ff00    	jmp	0		; HALT
; 273     90 802a_7c92    pp_case_3	incjne	pp_tmp,	pp_break
; 274     91 4018_ff00    	jmp	0		; HALT
; 276     92 4018_ff00    prep_piece_ret	jmp	0		; Return from subroutine
; 277                     
; 278                     ; Render buffer subroutine
; 279                     ;
; 280     93              render_ptr	skip	1
; 281     94              render_row	skip	1
; 282     95              render_rows	skip	1		; Rename height?
; 283     96              render_col	skip	1
; 284     97              render_cols	skip	1		; Rename stride?
; 285                     
; 286     98              render_r_rem	skip	1
; 287     99              render_c_rem	skip	1
; 288     9a              render_tmp	skip	2
; 294                     
; 295     9c 0800_93a8    	st	render_ptr,	r_buf_lo
; 296                     
; 297     9d 0800_9400    	st	render_row,	tmp
; 298     9e 0880_0000    	lsl	tmp
; 299     9f 0880_00a8    	addto	tmp,	r_buf_lo
; 300                     
; 301     a0 0800_9500    	st	render_rows,	tmp
; 302     a1 48e0_0100    	dec	tmp
; 303     a2 0880_0000    	lsl	tmp
; 304     a3 0880_00a8    	addto	tmp,	r_buf_lo
; 305                     
; 306     a4 0800_a8aa    	st	r_buf_lo,	r_buf_hi
; 307     a5 4880_01aa    	inc	r_buf_hi
; 308                     
; 310     a6 0860_9598    	negto	render_rows,	render_r_rem
; 311                     
; 313     a7 4800_009a    	clr	render_tmp+0
; 314     a8 8080_9a00    r_buf_lo	add	render_tmp+0,	0
; 315     a9 4800_009b    	clr	render_tmp+1
; 316     aa 8080_9b00    r_buf_hi	add	render_tmp+1,	0
; 317                     
; 319     ab 0860_9799    	negto	render_cols,	render_c_rem
; 322     ac 0a00_9b9b    	lsr	render_tmp+1		; 0 -> bit 7. Bit 0 -> C
; 323     ad 0a10_9a9a    	ror	render_tmp+0		; C -> bit 7. Bit 0 -> C
; 324                     
; 325     ae 0064_00b1    	jcc	r_print_e		; Print empty square if C==0
; 326     af 9800_0200    	outc	block_char		; Else print block
; 327     b0 4018_ffb2    	jmp	r_after
; 328     b1 9800_0300    r_print_e	outc	empty_char
; 330     b2 d800_7c00    	outc	#0x7C ; TEST
; 331     b3 802a_99ac    	incjne	render_c_rem,	r_print_loop
; 333                     
; 336     b4 9800_0400    	outc	newline+0
; 337     b5 9800_0500    	outc	newline+1
; 338                     
; 339     b6 48e0_02a8    	rsbto	#2,	r_buf_lo	; Subtract 2 from each pointer
; 340     b7 48e0_02aa    	rsbto	#2,	r_buf_hi
; 341     b8 802a_98a7    	incjne	render_r_rem,	r_loop
; 343                     
; 344     b9 4018_ff00    render_ret	jmp	0
; 345                     
; 346                     ; Clear buffer subroutine
; 347                     ;
; 348     ba              clrbuf_ptr	skip	1
; 349     bb              clrbuf_len	skip	1
; 351     bc 0860_bb00    	negto	clrbuf_len,	tmp
; 352     bd 0800_babe    	st	clrbuf_ptr,	clrbuf_clr
; 354     be 4800_0000    clrbuf_clr	clr	0		; Indirect clear
; 355     bf 4880_01be    	inc	clrbuf_clr
; 356     c0 802a_00be    	incjne	tmp,	clrbuf_loop
; 357     c1 4018_ff00    clrbuf_ret	jmp	0
; 358                     
; 359                     ; Right shift subroutine
; 360                     ;
; 361     c2              rshift_val	skip	1
; 362     c3              rshift_n	skip	1
; 363     c4 0860_c300    rshift	negto	rshift_n,	tmp
; 364     c5 0a00_c2c2    rshift_loop	lsr	rshift_val
; 365     c6 802a_00c5    	incjne	tmp,	rshift_loop
; 366     c7 4018_ff00    rshift_ret	jmp	0		; Return from subroutine
; 367                     

; 0 errors detected in pass 2

; Symbol table:
; block_char = 0x2
; clrbuf = 0xbc
; clrbuf_clr = 0xbe
; clrbuf_len = 0xbb
; clrbuf_loop = 0xbe
; clrbuf_ptr = 0xba
; clrbuf_ret = 0xc1
; current_cleared = 0xd
; current_piece = 0xe
; current_pose = 0xf
; current_x = 0x10
; current_y = 0x11
; empty_char = 0x3
; exec = 0x1
; gameboard = 0x14
; i_piece = 0xc
; j_piece = 0xa
; l_piece = 0x9
; newline = 0x4
; o_piece = 0xb
; piece_stage = 0x3c
; pieces_arr = 0x6
; pp_break = 0x92
; pp_case_0 = 0x86
; pp_case_1 = 0x8c
; pp_case_2 = 0x8e
; pp_case_3 = 0x90
; pp_tmp = 0x7c
; prep_piece = 0x7d
; prep_piece_ret = 0x92
; r_after = 0xb2
; r_buf_hi = 0xaa
; r_buf_lo = 0xa8
; r_loop = 0xa7
; r_loop_end = 0xb9
; r_print_e = 0xb1
; r_print_loop = 0xac
; render = 0x9c
; render_c_rem = 0x99
; render_col = 0x96
; render_cols = 0x97
; render_ptr = 0x93
; render_r_rem = 0x98
; render_ret = 0xb9
; render_row = 0x94
; render_rows = 0x95
; render_tmp = 0x9a
; rshift = 0xc4
; rshift_loop = 0xc5
; rshift_n = 0xc3
; rshift_ret = 0xc7
; rshift_val = 0xc2
; run = 0x45
; s_piece = 0x7
; shift_stage = 0x63
; shift_stage_n = 0x62
; shift_stage_ret = 0x7a
; ss_left = 0x66
; ss_right = 0x70
; ss_right_loop = 0x71
; t_piece = 0x6
; template_cpy = 0x7b
; template_ptr = 0x80
; test_loop = 0x4a
; test_loop_i = 0x44
; tmp = 0x0
; z_piece = 0x8

; Memory image:
00: c810ff00 4018ff45 c810ff23 c810ff20 c810ff0d c810ff0a c810ff72 c810ff63
08: c810ff36 c810ff47 c810ff74 c810ff66 c810fff0
12: c810ffff c810ffff
45: 4800000e 4800000f 48000010
48: 48001011 4800fa44 4880010e 8408927d 48003c93 48000094 48000495 48000096
50: 48000a97 48000462 84087a63 8408b99c 48000262 84087a63 8408b99c 4800fa62
58: 84087a63 8408b99c 802a444a 98000400 98000500 d8004800 d8004100 d8004c00
60: d8005400 c810ff00
63: 08806210 08006200 00690070 0a003d3d 0a103c3c
68: 0a003f3f 0a103e3e 0a004141 0a104040 0a004343 0a104242 802a0066 4018ff7a
70: 08600000 08803c3c 08903d3d 08803e3e 08903f3f 08804040 08904141 08804242
78: 08904343 802a0071 4018ff00
7d: 48000680 08800e80 4800007b
80: 80807b00 48003cba 480008bb 8408c1bc 480004c3 08600f7c 006a7c8c 08007b3c
88: 49800f3c 08007bc2 8408c7c4 0800c23e 802a7c8e 4018ff00 802a7c90 4018ff00
90: 802a7c92 4018ff00 4018ff00
9c: 080093a8 08009400 08800000 088000a8
a0: 08009500 48e00100 08800000 088000a8 0800a8aa 488001aa 08609598 4800009a
a8: 80809a00 4800009b 80809b00 08609799 0a009b9b 0a109a9a 006400b1 98000200
b0: 4018ffb2 98000300 d8007c00 802a99ac 98000400 98000500 48e002a8 48e002aa
b8: 802a98a7 4018ff00
bc: 0860bb00 0800babe 48000000 488001be
c0: 802a00be 4018ff00
c4: 0860c300 0a00c2c2 802a00c5 4018ff00
