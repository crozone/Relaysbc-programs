; Pass 1...

; 0 errors detected in pass 1

; Pass 2...
; 1                       ; Tetris implementation
; 2                       ; Ryan Crosby 2022
; 3                       ;
; 4                       ; Run from 0x01.
; 5                       ;
; 6                       ; Controls:
; 7                       ;
; 8                       ; Relay computer numpad is used to control the game.
; 9                       ;
; 10                      ; 2: Move piece down
; 11                      ; 4: Move piece left
; 12                      ; 6: Move piece right
; 13                      ; 7: Rotate piece left
; 14                      ; 9: Rotate piece right
; 15                      ;
; 16                      ; Game is rendered to console output.
; 17                      ;
; 18                      ; TODO:
; 19                      ;
; 20                      ; * Game over (Current code infinite loops on game over)
; 21                      ; * Further optimise code to free up some instruction space to implement above TODOs.
; 22                      ;
; 23                      
; 24                      ; =========
; 25                      ; Constants
; 26                      ; =========
; 27                      
; 28                      ; Gameboard parameters
; 29                      ; These constants are used for convenience. Changing the value won't change the actual sizes of the gameboards, code will need to be modified as well.
; 30      0000_0000       GAMEBOARD_STRIDE	equ	2	; How many bytes high is the gameboard. 2 bytes = 16 rows.
; 31      0000_0000       GAMEBOARD_COLS	equ	10	; How many columns wide is the gameboard. This is generic enough that it can be adjusted without altering any code.
; 32      0000_0000       GAMEBOARD_SIZE	equ	(GAMEBOARD_STRIDE*GAMEBOARD_COLS)	; Gameboard total size = stride * columns
; 33                      
; 34      0000_0000       PIECE_STAGE_SIZE	equ	(GAMEBOARD_STRIDE*4)	; The piece stage is the same height as the gameboard, but only 4 wide.
; 35                      
; 36      0000_0000       PIECE_X_OFFSET	equ	3	; The piece always spawns at x = 0. This offsets the piece so that x = 0 aligns with the center of the board.
; 37                      
; 38      0000_0000       SPACE_CHAR	equ	0x20	; Space
; 39      0000_0000       BLOCK_CHAR	equ	0x23	; #
; 40      0000_0000       EMPTY_CHAR	equ	0x7E 	; ~
; 41      0000_0000       BAR_CHAR	equ	0x7C	; |
; 42                      
; 43      0000_0000       CR_CHAR	equ	0x0D	; Carriage Return CR \r
; 44      0000_0000       LF_CHAR	equ	0x0A	; Linefeed LF \n
; 45                      
; 46                      ; Additional custom instructions
; 47                      ; To use these, call them like: insn INCTO_INSN aa, bb
; 48      0000_0000       IMADD_INSN	equ	0xC0800000	; aa + [bb] --> [aa]. Immediate version of ADD. If aa is 0, allows single instruction LOAD of [bb] to [0].
; 49      0000_0000       AND_INSN	equ	0x81800000	; The WRA version of andto. ANDs [aa] and [bb], and stores in [aa].
; 50      0000_0000       CLRA_INSN	equ	0x81000000	; Stores 0 --> [aa]. Implemented as [aa] & 0 --> [aa].
; 51      0000_0000       INCA_INSN	equ	0x80200000	; Stores [aa] + 1 --> [aa] in one instruction.
; 52      0000_0000       INCTO_INSN	equ	0x08200000	; Stores [aa] + 1 --> [bb] in one instruction.
; 53      0000_0000       ALTB_TOC_INSN	equ	0x00C00000	; Stores [aa] < [bb] --> Carry.
; 54      0000_0000       ALEB_TOC_INSN	equ	0x00E00000	; Stores [aa] <= [bb] --> Carry.
; 55      0000_0000       ST_JMP_INSN	equ	0x08080000	; Stores [aa] --> [bb] and jumps to bb.
; 56      0000_0000       OUTC_JMP_INSN	equ	0x98080000	; Writes [aa] to the console and jumps to bb. WRA and WRB are set to make OUT write to console.
; 57      0000_0000       LSR_JCC_INSN	equ	0x820A0000	; Rotates [aa] right, writes the result back to [aa], and jumps if the shifted out bit (carry output) was clear.
; 58      0000_0000       INCJMP_INSN	equ	0x80280000	; Stores [aa] + 1 --> [aa] and unconditionally jumps to bb
; 59                      
; 60                      ; Pieces templates
; 61                      ;
; 62                      ; Piece patterns are stored as a single byte.
; 63                      ; The 4 lsb bits represent the left of the piece, the 4 msb bits representing the right of the piece.
; 64                      ; The alignment and bit direction matches the piece stage.
; 65                      ;
; 66                      ; A "flipped" version of each piece is also stored, which is similar to the piece being left-to-right bitswapped.
; 67                      ; However using a dedicated version of the flipped piece removes the need for a bitswap subroutine,
; 68                      ; which actually saves instructions overall, and also allows the pieces to be tweaked so that they rotate correctly.
; 69                      ;
; 70                      ; The Gameboy left-handed rotation system was used as a reference, but the code doesn't attempt to exactly adhere to any particular system,
; 71                      ; it just attempts to look somewhat acceptable and use minimal instructions.
; 72                      
; 73                      
; 74                      ; I piece
; 75                      ;
; 76                      ;3   7
; 77                      ; 0 1
; 78                      ; 0 1
; 79                      ; 0 1
; 80                      ; 0 1
; 81                      ;0   4
; 82      0000_0000       I_PIECE	equ	0xF0
; 83      0000_0000       I_PIECE_FLIP	equ	I_PIECE	; I piece is the same flipped
; 84                      
; 85                      ; O (square) piece
; 86                      ;
; 87                      ;3   7
; 88                      ; 0 0
; 89                      ; 1 1
; 90                      ; 1 1
; 91                      ; 0 0
; 92                      ;0   4
; 93      0000_0000       O_PIECE	equ	0x66
; 94      0000_0000       O_PIECE_FLIP	equ	O_PIECE	; Square is same in any rotation
; 95                      
; 96                      ; T piece
; 97                      ;
; 98                      ;3   7
; 99                      ; 0 0
; 100                     ; 1 0
; 101                     ; 1 1
; 102                     ; 1 0
; 103                     ;0   4
; 104     0000_0000       T_PIECE	equ	0x27
; 105                     
; 106                     ; T piece flipped
; 107                     ;
; 108                     ;3   7
; 109                     ; 0 0
; 110                     ; 0 1
; 111                     ; 1 1
; 112                     ; 0 1
; 113                     ;0   4
; 114     0000_0000       T_PIECE_FLIP	equ	0x72
; 115                     
; 116                     ; S piece
; 117                     ;
; 118                     ;3   7
; 119                     ; 0 0
; 120                     ; 1 0
; 121                     ; 1 1
; 122                     ; 0 1
; 123                     ;0   4
; 124     0000_0000       S_PIECE	equ	0x36
; 125     0000_0000       S_PIECE_FLIP	equ	S_PIECE	; S piece is the same rotated
; 126                     
; 127                     ; S piece
; 128                     ;
; 129                     ;3   7
; 130                     ; 0 0
; 131                     ; 0 1
; 132                     ; 1 1
; 133                     ; 1 0
; 134                     ;0   4
; 135     0000_0000       Z_PIECE	equ	0x63
; 136     0000_0000       Z_PIECE_FLIP	equ	Z_PIECE	; Z piece is the same rotated
; 137                     
; 138                     ; J piece
; 139                     ;
; 140                     ;3   7
; 141                     ; 0 0
; 142                     ; 0 1
; 143                     ; 0 1
; 144                     ; 1 1
; 145                     ;0   4
; 146     0000_0000       J_PIECE	equ	0x71
; 147                     
; 148                     ; J piece flipped
; 149                     ;
; 150                     ;3   7
; 151                     ; 0 0
; 152                     ; 1 1
; 153                     ; 1 0
; 154                     ; 1 0
; 155                     ;0   4
; 156     0000_0000       J_PIECE_FLIP	equ	0x47
; 157                     
; 158                     ; L piece
; 159                     ;
; 160                     ;3   7
; 161                     ; 0 0
; 162                     ; 1 0
; 163                     ; 1 0
; 164                     ; 1 1
; 165                     ;0   4
; 166     0000_0000       L_PIECE	equ	0x17
; 167                     
; 168                     ; L piece flipped
; 169                     ;
; 170                     ;3   7
; 171                     ; 0 0
; 172                     ; 1 1
; 173                     ; 0 1
; 174                     ; 0 1
; 175                     ;0   4
; 176     0000_0000       L_PIECE_FLIP	equ	0x74
; 177                     
; 178                     ; ================
; 179                     ; Application code
; 180                     ; ================
; 181                     
; 182                     ; Temporary variable tmp at address 0x00.
; 183                     ;
; 184                     ; Used as a halt catch for any jumps to null (0x00). This usually indicates a subroutine hasn't had its return address set.
; 185                     ; Also used as a temporary storage register, and sometimes as the return value for subroutines that only need to return a status.
; 186                     
; 187     00              	org	0x00
; 189     00 c810_ff00    tmp	halt
; 190                     
; 191                     ; ENTRY POINT
; 192     01              	org	0x01
; 195                     
; 196     01 8100_0100    lines_cleared	insn CLRA_INSN	lines_cleared,	0
; 197     02 8100_0200    piece_kind	insn CLRA_INSN	piece_kind,	0
; 198     03 8100_0300    piece_x	insn CLRA_INSN	piece_x,	0
; 199     04 8100_0400    piece_y	insn CLRA_INSN	piece_y,	0
; 200     05 8100_0500    piece_rotation	insn CLRA_INSN	piece_rotation,	0
; 201                     
; 234                     
; 235     06 0000_00ff    	insn 0x00000000	,	0xFF	; A wall for the gameboard to provide collisions at column -1
; 236     07 0000_00ff    	insn 0x00000000	,	0xFF
; 238     08 8100_0800    	insn CLRA_INSN	gameboard+0,	0
; 239     09 8100_0900    	insn CLRA_INSN	gameboard+1,	0
; 240     0a 8100_0a00    	insn CLRA_INSN	gameboard+2,	0
; 241     0b 8100_0b00    	insn CLRA_INSN	gameboard+3,	0
; 242     0c 8100_0c00    	insn CLRA_INSN	gameboard+4,	0
; 243     0d 8100_0d00    	insn CLRA_INSN	gameboard+5,	0
; 244     0e 8100_0e00    	insn CLRA_INSN	gameboard+6,	0
; 245     0f 8100_0f00    	insn CLRA_INSN	gameboard+7,	0
; 246     10 8100_1000    	insn CLRA_INSN	gameboard+8,	0
; 247     11 8100_1100    	insn CLRA_INSN	gameboard+9,	0
; 248     12 8100_1200    	insn CLRA_INSN	gameboard+10,	0
; 249     13 8100_1300    	insn CLRA_INSN	gameboard+11,	0
; 250     14 8100_1400    	insn CLRA_INSN	gameboard+12,	0
; 251     15 8100_1500    	insn CLRA_INSN	gameboard+13,	0
; 252     16 8100_1600    	insn CLRA_INSN	gameboard+14,	0
; 253     17 8100_1700    	insn CLRA_INSN	gameboard+15,	0
; 254     18 8100_1800    	insn CLRA_INSN	gameboard+16,	0
; 255     19 8100_1900    	insn CLRA_INSN	gameboard+17,	0
; 256     1a 8100_1a00    	insn CLRA_INSN	gameboard+18,	0
; 257     1b 8100_1b00    	insn CLRA_INSN	gameboard+19,	0
; 258     1c 0000_00ff    	insn 0x00000000	,	0xFF	; no-op/clc, but specified as custom instruction se we can set B value.
; 259     1d 0000_00ff    	insn 0x00000000	,	0xFF	; A wall for the gameboard to provide collisions at column 11
; 264     1e 40e0_0602    	insn ALEB_TOC_INSN	#6,	piece_kind	; Set carry if piece_kind >= 6.
; 265     1f 4890_0102    	adcto	#1,	piece_kind	; If carry set, increment by 2, otherwise increment by 1.
; 266     20 4980_0702    	andto	#0x07,	piece_kind	; Clear all bits above first three so that value wraps.
; 269     21 8100_2100    prev_piece_x	insn CLRA_INSN	prev_piece_x,	0
; 270     22 8100_2200    prev_piece_y	insn CLRA_INSN	prev_piece_y,	0
; 271     23 8100_2300    prev_piece_rotation	insn CLRA_INSN	prev_piece_rotation,	0
; 275     24 8408_5f5c    main_undo_then_render	jsr	undo_piece_state_ret,	undo_piece_state
; 301     25 8100_2500    	insn CLRA_INSN	piece_stage+0,	0
; 302     26 8100_2600    	insn CLRA_INSN	piece_stage+1,	0
; 303     27 8100_2700    	insn CLRA_INSN	piece_stage+2,	0
; 304     28 8100_2800    	insn CLRA_INSN	piece_stage+3,	0
; 305     29 8100_2900    	insn CLRA_INSN	piece_stage+4,	0
; 306     2a 8100_2a00    	insn CLRA_INSN	piece_stage+5,	0
; 307     2b 8100_2b00    	insn CLRA_INSN	piece_stage+6,	0
; 308     2c 8100_2c00    	insn CLRA_INSN	piece_stage+7,	0
; 311     2d 8408_8760    	jsr	prep_piece_ret,	prep_piece
; 314     2e 0800_0400    	st	piece_y,	tmp
; 315     2f 8408_9688    	jsr	shift_piece_ret,	shift_piece
; 323     30 4800_a1a0    	st	#stamp_piece_coll_op,	stamp_piece_op
; 324     31 8408_ad97    	jsr	stamp_piece_ret,	stamp_piece
; 325     32 006a_0024    	jne	tmp,	main_undo_then_render	; We have a collision. Undo changes and re-render.
; 328     33 4800_a5a0    	st	#stamp_piece_merge_op,	stamp_piece_op
; 329     34 8408_ad97    	jsr	stamp_piece_ret,	stamp_piece
; 332     35 0062_3739    	jeq	stamp_flag,	main_no_stamp_flag
; 334     36 8408_d6c2    	jsr	line_clr_ret,	line_clr
; 336     37 8100_3700    stamp_flag	insn CLRA_INSN	stamp_flag,	0
; 337     38 4018_ff1e    	jmp	main_next_piece
; 340     39 8408_c1ae    	jsr	render_board_ret,	render_board
; 341                     
; 343     3a 4800_a7a0    	st	#stamp_piece_clear_op,	stamp_piece_op
; 344     3b 8408_ad97    	jsr	stamp_piece_ret,	stamp_piece
; 347     3c 8408_5b58    	jsr	save_piece_state_ret,	save_piece_state
; 348                     
; 353     3d e800_0000    	inwait	tmp
; 358     3e 48e0_0200    	rsbto	#02,	tmp
; 359     3f 0062_0049    	jeq	tmp,	main_move_drop
; 363     40 48e0_0200    	rsbto	#02,	tmp
; 364     41 0062_0052    	jeq	tmp,	main_move_left
; 368     42 48e0_0200    	rsbto	#02,	tmp
; 369     43 0062_0054    	jeq	tmp,	main_move_right
; 373     44 48e0_0100    	rsbto	#01,	tmp
; 374     45 0062_0055    	jeq	tmp,	main_rot_left
; 378     46 48e0_0200    	rsbto	#02,	tmp
; 379     47 0062_0057    	jeq	tmp,	main_rot_right
; 380                     
; 382     48 d808_3f3d    	insn OUTC_JMP_INSN	#0x3F,	main_read_input	; Print '?'
; 385     49 48e0_0104    	dec	piece_y
; 386     4a 4800_ff00    	st	#-1,	tmp
; 387     4b 8408_9688    	jsr	shift_piece_ret,	shift_piece
; 390     4c 0062_004e    	jeq	tmp,	main_move_drop_2
; 393     4d 8028_3733    	insn INCJMP_INSN	stamp_flag,	main_full_render	; Re-render board and restart game loop.
; 396     4e 4800_a1a0    	st	#stamp_piece_coll_op,	stamp_piece_op
; 397     4f 8408_ad97    	jsr	stamp_piece_ret,	stamp_piece
; 398     50 0062_0033    	jeq	tmp,	main_full_render	; No collision, re-render board.
; 401     51 8028_3724    	insn INCJMP_INSN	stamp_flag,	main_undo_then_render	; Undo piece movement to move piece back up one, then re-render board and restart game loop.
; 403     52 48e0_0103    	dec	piece_x
; 404     53 4018_ff30    	jmp	main_check_collision
; 408     54 8028_0330    	insn INCJMP_INSN	piece_x,	main_check_collision
; 410     55 48e0_0105    	dec	piece_rotation
; 411     56 4018_ff25    	jmp	main_render_fresh_piece
; 415     57 8028_0525    	insn INCJMP_INSN	piece_rotation,	main_render_fresh_piece
; 417                     
; 419     58 0800_0523    	st	piece_rotation,	prev_piece_rotation
; 420     59 0800_0321    	st	piece_x,	prev_piece_x
; 421     5a 0800_0422    	st	piece_y,	prev_piece_y
; 422     5b 4018_ff00    save_piece_state_ret	jmp	0
; 423                     
; 425     5c 0800_2305    	st	prev_piece_rotation,	piece_rotation
; 426     5d 0800_2103    	st	prev_piece_x,	piece_x
; 427     5e 0800_2204    	st	prev_piece_y,	piece_y
; 428     5f 4018_ff00    undo_piece_state_ret	jmp	0
; 429                     
; 430                     ; Prepare piece stage subroutine
; 431                     ; piece_kind = which piece to render. {0,1,2,3,4,5,6}
; 432                     ;
; 433                     ; Piece rotation. 4 different values for each direction. {0,1,2,3}. Only uses bottom two bits, so can increment forever.
; 434                     ;
; 436     60 0800_0265    	st	piece_kind,	prep_piece_target	; We're rendering the current piece_kind
; 443     61 0a00_0500    	lsrto	piece_rotation,	tmp	; We're rendering the current piece_rotation
; 444     62 0a00_0000    	lsr	tmp
; 445     63 0890_6565    	adcto	prep_piece_target,	prep_piece_target
; 447     64 4880_6665    	addto	#prep_piece_jmp,	prep_piece_target
; 449     65 4018_ff00    prep_piece_target	jmp	0
; 451     66 4808_6674    	insn ST_JMP_INSN	#O_PIECE,	prep_piece_value
; 452     67 4808_6674    	insn ST_JMP_INSN	#O_PIECE_FLIP,	prep_piece_value
; 453     68 4808_f074    	insn ST_JMP_INSN	#I_PIECE,	prep_piece_value
; 454     69 4808_f074    	insn ST_JMP_INSN	#I_PIECE_FLIP,	prep_piece_value
; 455     6a 4808_2774    	insn ST_JMP_INSN	#T_PIECE,	prep_piece_value
; 456     6b 4808_7274    	insn ST_JMP_INSN	#T_PIECE_FLIP,	prep_piece_value
; 457     6c 4808_3674    	insn ST_JMP_INSN	#S_PIECE,	prep_piece_value
; 458     6d 4808_3674    	insn ST_JMP_INSN	#S_PIECE_FLIP,	prep_piece_value
; 459     6e 4808_6374    	insn ST_JMP_INSN	#Z_PIECE,	prep_piece_value
; 460     6f 4808_6374    	insn ST_JMP_INSN	#Z_PIECE_FLIP,	prep_piece_value
; 461     70 4808_7174    	insn ST_JMP_INSN	#J_PIECE,	prep_piece_value
; 462     71 4808_4774    	insn ST_JMP_INSN	#J_PIECE_FLIP,	prep_piece_value
; 463     72 4808_1774    	insn ST_JMP_INSN	#L_PIECE,	prep_piece_value
; 464     73 4808_7474    	insn ST_JMP_INSN	#L_PIECE_FLIP,	prep_piece_value
; 465     74 4010_ff00    prep_piece_value	nop	; prep_piece_value stores the jump table result.
; 466                     
; 468     75 0202_057d    	jo	piece_rotation,	prep_piece_hor
; 470     76 0800_742a    	st	prep_piece_value,	piece_stage+5
; 471     77 4980_f02a    	andto	#0xF0,	piece_stage+5	; Clear lower 4 bits
; 472     78 4800_fc00    	st	#-4,	tmp
; 473     79 0880_7474    prep_piece_vert_loop	lsl	prep_piece_value
; 474     7a 802a_0079    	incjne	tmp,	prep_piece_vert_loop
; 475     7b 0800_7428    	st	prep_piece_value,	piece_stage+3
; 476     7c 4018_ff87    	jmp	prep_piece_ret
; 478     0000_007d       prep_piece_hor_i	equ	prep_piece_target		; Reuse prep_piece_target as the outer loop variable.
; 479     7d 4800_fd65    	st	#-3,	prep_piece_hor_i
; 481     7e 4800_2c80    	st	#(piece_stage+7),	prep_piece_hor_ptr
; 483     7f 0800_8082    	st	prep_piece_hor_ptr,	prep_piece_hor_wb_ptr
; 484     80 c080_0000    prep_piece_hor_ptr	insn IMADD_INSN	tmp,	0	; LOAD
; 485     81 0a00_7474    	lsr	prep_piece_value
; 486     82 0a10_0000    prep_piece_hor_wb_ptr	rorto	tmp,	0	; STORE
; 487     83 48e0_0280    	rsbto	#2,	prep_piece_hor_ptr
; 488     84 40e0_2580    	insn ALEB_TOC_INSN	#piece_stage,	prep_piece_hor_ptr
; 489     85 006c_007f    	jcs	prep_piece_hor_loop_b		; Loop if #piece_stage <= prep_piece_hor_ptr
; 490     86 802a_657e    	incjne	prep_piece_hor_i,	prep_piece_hor_loop_a
; 491     87 4018_ff00    prep_piece_ret	jmp	0
; 492                     
; 493                     ; shift_piece subroutine.
; 494                     ;
; 495                     ; Shifts the piece stage downwards by the set amount stored negated in tmp.
; 496                     ; If the piece is shifted to the bottom of the board, stops and returns non-zero in tmp.
; 498     88 0062_0096    	jeq	tmp,	shift_piece_ret
; 500     89 0202_2b96    	jo	piece_stage+6,	shift_piece_ret
; 501     8a 0202_2996    	jo	piece_stage+4,	shift_piece_ret
; 502     8b 0202_2796    	jo	piece_stage+2,	shift_piece_ret
; 503     8c 0202_2596    	jo	piece_stage+0,	shift_piece_ret
; 505     8d 0a00_2c2c    	lsr	piece_stage+7
; 506     8e 0a10_2b2b    	ror	piece_stage+6
; 507     8f 0a00_2a2a    	lsr	piece_stage+5
; 508     90 0a10_2929    	ror	piece_stage+4
; 509     91 0a00_2828    	lsr	piece_stage+3
; 510     92 0a10_2727    	ror	piece_stage+2
; 511     93 0a00_2626    	lsr	piece_stage+1
; 512     94 0a10_2525    	ror	piece_stage+0
; 513     95 802a_0089    	incjne	tmp,	shift_piece_loop
; 514     96 4018_ff00    shift_piece_ret	jmp	0	; Return from subroutine
; 515                     
; 516                     ; stamp_piece: Stamp piece board subroutine.
; 517                     ;
; 518                     ; This subroutine handles several functions:
; 519                     ;
; 520                     ; * ADDing the piece_stage to the gameboard (Stamping the piece down)
; 521                     ; * BICing the piece_stage to the gameboard (Clearing the piece off)
; 522                     ; * Checking for any common bits (AND result > 0) between piece_stage and gameboard (Checking for collision).
; 523                     ;
; 524                     ; stamp_piece_op must be set to #stamp_piece_coll_op, #stamp_piece_merge_op, or #stamp_piece_clear_op before executing.
; 525                     ;
; 526                     ; When executing stamp_piece_coll_op, tmp will be non-zero if a collision occured.
; 527                     ;
; 530     97 4800_259d    	st	#piece_stage,	stamp_piece_ps_ptr
; 531     98 4800_0e9f    	st	#(gameboard+(PIECE_X_OFFSET*2)),	stamp_piece_gb_ptr
; 532     99 0880_039f    	addto	piece_x,	stamp_piece_gb_ptr
; 533     9a 0880_039f    	addto	piece_x,	stamp_piece_gb_ptr	; stamp_piece_gb_ptr = #gameboard + 2 * piece_x
; 536     9b 4800_f800    	st	#-PIECE_STAGE_SIZE,	tmp
; 538                     
; 539     9c 8100_9c00    stamp_piece_ps_val	insn CLRA_INSN	stamp_piece_ps_val,	0	; Self clearing variable stamp_piece_ps_val
; 540     9d 8080_9c00    stamp_piece_ps_ptr	add	stamp_piece_ps_val,	0	; Piece stage LOAD
; 542     9e 8100_9e00    stamp_piece_gb_val	insn CLRA_INSN	stamp_piece_gb_val,	0	; Self clearing variable stamp_piece_gb_val
; 543     9f 8080_9e00    stamp_piece_gb_ptr	add	stamp_piece_gb_val,	0	; Game board LOAD
; 544                     
; 546     a0 4018_ff00    stamp_piece_op	jmp	0	; This is set before calling the subroutine
; 549     a1 0980_9c9e    	andto	stamp_piece_ps_val,	stamp_piece_gb_val
; 550     a2 0062_9eaa    	jeq	stamp_piece_gb_val,	stamp_piece_loop_end	; If collision didn't occur, keep looping.
; 552     a3 0800_9e00    	st	stamp_piece_gb_val,	tmp	; Store colliding bits in tmp
; 553     a4 4018_ffad    	jmp	stamp_piece_ret		; Break out of loop and exit
; 557     a5 0880_9c9e    	addto	stamp_piece_ps_val,	stamp_piece_gb_val
; 558     a6 4018_ffa8    	jmp	stamp_piece_writeback
; 560     a7 09c0_9c9e    	bicto	stamp_piece_ps_val,	stamp_piece_gb_val
; 562     a8 0800_9fa9    	st	stamp_piece_gb_ptr,	stamp_piece_gb_wb_ptr
; 563     a9 0800_9e00    stamp_piece_gb_wb_ptr	st	stamp_piece_gb_val,	0	; Game board STORE
; 566     aa 8020_9d00    rem_bits_mask	insn INCA_INSN	stamp_piece_ps_ptr,	0	; Variable storage for rem_bits_mask, in rem_bits
; 567     ab 8020_9f00    	insn INCA_INSN	stamp_piece_gb_ptr,	0
; 568     ac 802a_009c    	incjne	tmp,	stamp_piece_loop
; 569     ad 4018_ff00    stamp_piece_ret	jmp	0	; Return from subroutine
; 570                     
; 571                     ; render_board: Render board subroutine
; 572                     ;
; 573                     ; How:
; 574                     ; Render the gameboard from left to right, top to bottom, to give the most simple console output (avoids ANSI console cursor movement).
; 575                     ;
; 576                     ; LOOP A: Starts at top of the board and then switches to bottom half of the board. The gameboard ptr offset changes from 1 to 0. (or 2 -> 1 -> 0 if using a bigger game board)
; 577                     ; LOOP B: Work down the rows using a single byte bitmask, shifting it right each iteration.
; 578                     ; LOOP C: Work along the columns from 0 to 10, incrementing the gameboard ptr by 2 each iteration.
; 579                     ;         Decide whether to render a block or empty character by ANDing the gameboard ptr value with the current bitmask
; 580                     ;
; 582     ae 4800_01b3    	st	#(GAMEBOARD_STRIDE-1),	render_board_ptr	; Start the render_board_ptr with an offset of 1 to render the top half of the board.
; 583                     ; LOOP A
; 585     af 4880_08b3    	addto	#gameboard,	render_board_ptr	; Adjust the render_board_ptr to point into the gameboard. TODO: Move out of loop after implementing ALEB_TOC_INSN below since this won't be changed.
; 586     b0 4800_80ba    	st	#%1000_0000,	render_board_mask	; Initialize the bitmask for testing the column byte for which row is set
; 587                     ; LOOP B
; 589     b1 4800_f6bb    	st	#(-GAMEBOARD_COLS),	render_board_col	; Prepare column loop counter
; 590                     ; LOOP C
; 592     b2 0800_ba00    	st	render_board_mask,	tmp
; 593     b3 8180_0000    render_board_ptr	insn AND_INSN	tmp,	0	; Indirect AND, store result in tmp
; 596     b4 006a_00b6    	jne	tmp,	render_board_print_a
; 597     b5 d808_7eb7    	insn OUTC_JMP_INSN	#EMPTY_CHAR,	render_board_print_b	; Print empty char and jump over the block char print
; 599     b6 d800_2300    line_clr_i	outc	#BLOCK_CHAR		; Used as variable storage for line_clr_i in line_clr
; 601     b7 4880_02b3    	addto	#GAMEBOARD_STRIDE,	render_board_ptr	; Move onto next column byte
; 602     b8 802a_bbb2    	incjne	render_board_col,	render_board_loop_c	; If we still have columns to render, continue LOOP C
; 603                     ; END LOOP C
; 604     b9 48e0_14b3    	rsbto	#GAMEBOARD_SIZE,	render_board_ptr	; Reset render_board_ptr to pre-loop state
; 608     ba d800_0d00    render_board_mask	outc	#CR_CHAR		; render_board_mask: The row bitmask for selecting the row to render
; 609     bb d800_0a00    render_board_col	outc	#LF_CHAR		; render_board_col: The current column iteration loop counter.
; 610                     
; 613     bc 820a_bab1    	insn LSR_JCC_INSN	render_board_mask,	render_board_loop_b
; 614                     ; END LOOP B
; 617     bd 48e0_09b3    	rsbto	#(gameboard+1),	render_board_ptr	; TODO: Can replace with ALEB_TOC_INSN + jcs
; 619     be 0069_b3af    	jge	render_board_ptr,	render_board_loop_a	; Otherwise continue LOOP A.
; 621     bf d800_0d00    get_full_lines_mask	outc	#CR_CHAR		; get_full_lines_mask: variable for get_full_lines
; 622     c0 d800_0a00    	outc	#LF_CHAR
; 623                     ; END LOOP A
; 624     c1 4018_ff00    render_board_ret	jmp	0		; Return from subroutine.
; 625                     
; 626                     ; line_clr: Clears all full rows from the gameboard.
; 627                     ;
; 628                     ; How:
; 629                     ; 1. Call get_full_lines to generate a bitmask of all the complete rows
; 630                     ; 2. Call rem_bits on each column in the gameboard with a copy of the complete rows bitmask.
; 631                     ; 3. Copy the result back over the gameboard.
; 632                     ;
; 635     c2 8408_e0d7    	jsr	get_full_lines_ret,	get_full_lines
; 636                     
; 638     c3 006a_bfc6    	jne	get_full_lines_mask+0,	line_clr_do_remove
; 639     c4 006a_c0c6    	jne	get_full_lines_mask+1,	line_clr_do_remove
; 640     c5 4018_ffd6    	jmp	line_clr_ret	; Fastpath to returning from the subroutine
; 643     c6 8100_c600    rem_bits_value	insn CLRA_INSN	rem_bits_value+0,	0	; rem_bits_value: 2 bytes. Variable storage for rem_bits.
; 644     c7 8100_c700    	insn CLRA_INSN	rem_bits_value+1,	0	; Self clearing.
; 645                     
; 647     c8 4800_f6b6    	st	#(-GAMEBOARD_COLS),	line_clr_i	; Prep the loop counter
; 648                     
; 650     c9 4800_08cd    	st	#gameboard,	line_clr_read_ptr_0
; 652                     
; 653                     ; Line clear loop. It will call rem_bits with the line clear mask and each column of the gameboard.
; 657     ca 0800_bfaa    	st	get_full_lines_mask+0,	rem_bits_mask+0	; Prep mask +0
; 658     cb 0800_c0ab    	st	get_full_lines_mask+1,	rem_bits_mask+1	; Prep mask +1
; 659                     
; 661     cc 0820_cdce    	insn INCTO_INSN	line_clr_read_ptr_0,	line_clr_read_ptr_1	; Prep ptr +1
; 663     cd 8080_c600    line_clr_read_ptr_0	add	rem_bits_value+0,	0	; Load +0
; 664     ce 8080_c700    line_clr_read_ptr_1	add	rem_bits_value+1,	0	; Load +1
; 665                     
; 667     cf 8408_f1e1    	jsr	rem_bits_ret,	rem_bits
; 668                     
; 670     d0 0800_cdd2    	st	line_clr_read_ptr_0,	line_clr_write_ptr_0	; Prep ptr +0
; 671     d1 0800_ced3    	st	line_clr_read_ptr_1,	line_clr_write_ptr_1	; Prep ptr +1
; 673     d2 0800_e100    line_clr_write_ptr_0	st	rem_bits_result+0,	0	; Store +0
; 674     d3 0800_e200    line_clr_write_ptr_1	st	rem_bits_result+1,	0	; Store +1
; 675                     
; 677     d4 4880_02cd    	addto	#2,	line_clr_read_ptr_0	; Iterate ptr +0
; 678     d5 802a_b6ca    	incjne	line_clr_i,	line_clr_loop	; Loop
; 679     d6 4018_ff00    line_clr_ret	jmp	0		; Return from subroutine
; 680                     
; 681                     ; get_full_lines
; 682                     ;
; 683                     ; Generates a 2 byte, 16 bit bitmask indicating which rows in the gameboard are filled.
; 684                     ; This is the bitwise AND of all columns in the gameboard.
; 685                     ;
; 686                     ;get_full_lines_mask	skip	2	; Stored in render_board
; 688     d7 4800_f600    	st	#(-GAMEBOARD_COLS),	tmp
; 689     d8 4800_ffbf    	st	#0xFF,	get_full_lines_mask+0
; 690     d9 4800_ffc0    	st	#0xFF,	get_full_lines_mask+1
; 691     da 4800_08dc    	st	#gameboard,	get_full_lines_ptr_0
; 693     db 0820_dcdd    	insn INCTO_INSN	get_full_lines_ptr_0,	get_full_lines_ptr_1
; 694     dc 8180_bf00    get_full_lines_ptr_0	insn AND_INSN	get_full_lines_mask+0,	0
; 695     dd 8180_c000    get_full_lines_ptr_1	insn AND_INSN	get_full_lines_mask+1,	0
; 696     de 4880_02dc    	addto	#2,	get_full_lines_ptr_0
; 697     df 802a_00db    	incjne	tmp,	get_full_lines_loop
; 698     e0 4018_ff00    get_full_lines_ret	jmp	0		; Return from subroutine
; 699                     
; 700                     ; rem_bits
; 701                     ;
; 702                     ; Remove the bits from rem_bits_value in the positions they are set in rem_bits_mask.
; 703                     ; For each bit removed, the more significant bits are shifted right to fill its place.
; 704                     ; The leftmost most significant bits are filled with zeroes.
; 705                     ;
; 706                     ; The output is placed in rem_bits_result.
; 707                     ; rem_bits_mask and rem_bits_value are zeroed as a result of this process.
; 708                     ;
; 709                     ;rem_bits_mask	skip	2	; Stored in stamp_piece
; 710                     ;rem_bits_value	skip	2	; Stored in line_clr
; 713     e1 8100_e100    rem_bits_result	insn CLRA_INSN	rem_bits_result+0,	0	; Self clearing variables
; 714     e2 8100_e200    	insn CLRA_INSN	rem_bits_result+1,	0
; 716     e3 4800_f000    	st	#-16,	tmp	; Loop 16 times
; 718     e4 0880_aaaa    	lsl	rem_bits_mask+0		; Logical shift left mask (0 -> bit 0)
; 719     e5 0890_abab    	rol	rem_bits_mask+1		; (bit 15 -> carry)
; 720     e6 0064_00ec    	jcc	rem_bits_A		; GOTO A if carry clear
; 722     e7 0880_c6c6    	lsl	rem_bits_value+0		; Logical shift left value (0 -> bit 0)
; 723     e8 0890_c7c7    	rol	rem_bits_value+1		; The carry result is discarded.
; 726     e9 40e0_f6b6    	insn ALEB_TOC_INSN	#(-GAMEBOARD_COLS),	line_clr_i	; If this is the first iteration of rem_bits (first column), store 1 in carry
; 727     ea 4890_0001    	adcto	#0,	lines_cleared	; Add carry to lines cleared
; 729     eb 4018_fff0    	jmp	rem_bits_loop_end
; 731     ec 0880_c6c6    	lsl	rem_bits_value+0		; Logical shift left value (0 -> bit 0)
; 732     ed 0890_c7c7    	rol	rem_bits_value+1		; (bit 15 -> carry)
; 733     ee 0890_e1e1    	rol	rem_bits_result+0		; Rotate left to save the carry into result (carry -> bit 0)
; 734     ef 0890_e2e2    	rol	rem_bits_result+1		; Carry from rotating result is discarded.
; 735     f0 802a_00e4    rem_bits_loop_end	incjne	tmp,	rem_bits_loop	; Loop
; 736     f1 4018_ff00    rem_bits_ret	jmp	0		; Return from subroutine
; 737                     
; 739     0000_00f2       PROGRAM_FREE_SPACE	equ	(256-PROGRAM_SIZE)
; 740                     
; 741                     

; 0 errors detected in pass 2

; Symbol table:
; ALEB_TOC_INSN = 0xe00000
; ALTB_TOC_INSN = 0xc00000
; AND_INSN = 0x81800000
; BAR_CHAR = 0x7c
; BLOCK_CHAR = 0x23
; CLRA_INSN = 0x81000000
; CR_CHAR = 0xd
; EMPTY_CHAR = 0x7e
; GAMEBOARD_COLS = 0xa
; GAMEBOARD_SIZE = 0x14
; GAMEBOARD_STRIDE = 0x2
; IMADD_INSN = 0xc0800000
; INCA_INSN = 0x80200000
; INCJMP_INSN = 0x80280000
; INCTO_INSN = 0x8200000
; I_PIECE = 0xf0
; I_PIECE_FLIP = 0xf0
; J_PIECE = 0x71
; J_PIECE_FLIP = 0x47
; LF_CHAR = 0xa
; LSR_JCC_INSN = 0x820a0000
; L_PIECE = 0x17
; L_PIECE_FLIP = 0x74
; OUTC_JMP_INSN = 0x98080000
; O_PIECE = 0x66
; O_PIECE_FLIP = 0x66
; PIECE_STAGE_SIZE = 0x8
; PIECE_X_OFFSET = 0x3
; PROGRAM_FREE_SPACE = 0xe
; PROGRAM_SIZE = 0xf2
; SPACE_CHAR = 0x20
; ST_JMP_INSN = 0x8080000
; S_PIECE = 0x36
; S_PIECE_FLIP = 0x36
; T_PIECE = 0x27
; T_PIECE_FLIP = 0x72
; Z_PIECE = 0x63
; Z_PIECE_FLIP = 0x63
; gameboard = 0x8
; get_full_lines = 0xd7
; get_full_lines_loop = 0xdb
; get_full_lines_mask = 0xbf
; get_full_lines_ptr_0 = 0xdc
; get_full_lines_ptr_1 = 0xdd
; get_full_lines_ret = 0xe0
; line_clr = 0xc2
; line_clr_do_remove = 0xc6
; line_clr_i = 0xb6
; line_clr_loop = 0xca
; line_clr_read_ptr_0 = 0xcd
; line_clr_read_ptr_1 = 0xce
; line_clr_ret = 0xd6
; line_clr_write_ptr_0 = 0xd2
; line_clr_write_ptr_1 = 0xd3
; lines_cleared = 0x1
; main = 0x1
; main_check_collision = 0x30
; main_end = 0x58
; main_full_render = 0x33
; main_move_drop = 0x49
; main_move_drop_2 = 0x4e
; main_move_left = 0x52
; main_move_right = 0x54
; main_next_piece = 0x1e
; main_no_stamp_flag = 0x39
; main_read_input = 0x3d
; main_render_fresh_piece = 0x25
; main_rot_left = 0x55
; main_rot_right = 0x57
; main_undo_then_render = 0x24
; piece_kind = 0x2
; piece_rotation = 0x5
; piece_stage = 0x25
; piece_x = 0x3
; piece_y = 0x4
; prep_piece = 0x60
; prep_piece_hor = 0x7d
; prep_piece_hor_i = 0x65
; prep_piece_hor_loop_a = 0x7e
; prep_piece_hor_loop_b = 0x7f
; prep_piece_hor_ptr = 0x80
; prep_piece_hor_wb_ptr = 0x82
; prep_piece_jmp = 0x66
; prep_piece_ret = 0x87
; prep_piece_target = 0x65
; prep_piece_value = 0x74
; prep_piece_vert = 0x76
; prep_piece_vert_loop = 0x79
; prev_piece_rotation = 0x23
; prev_piece_x = 0x21
; prev_piece_y = 0x22
; rem_bits = 0xe1
; rem_bits_A = 0xec
; rem_bits_loop = 0xe4
; rem_bits_loop_end = 0xf0
; rem_bits_mask = 0xaa
; rem_bits_result = 0xe1
; rem_bits_ret = 0xf1
; rem_bits_value = 0xc6
; render_board = 0xae
; render_board_col = 0xbb
; render_board_loop_a = 0xaf
; render_board_loop_b = 0xb1
; render_board_loop_c = 0xb2
; render_board_mask = 0xba
; render_board_print_a = 0xb6
; render_board_print_b = 0xb7
; render_board_ptr = 0xb3
; render_board_ret = 0xc1
; save_piece_state = 0x58
; save_piece_state_ret = 0x5b
; shift_piece = 0x88
; shift_piece_loop = 0x89
; shift_piece_ret = 0x96
; stamp_flag = 0x37
; stamp_piece = 0x97
; stamp_piece_clear_op = 0xa7
; stamp_piece_coll_op = 0xa1
; stamp_piece_gb_ptr = 0x9f
; stamp_piece_gb_val = 0x9e
; stamp_piece_gb_wb_ptr = 0xa9
; stamp_piece_loop = 0x9c
; stamp_piece_loop_end = 0xaa
; stamp_piece_merge_op = 0xa5
; stamp_piece_op = 0xa0
; stamp_piece_ps_ptr = 0x9d
; stamp_piece_ps_val = 0x9c
; stamp_piece_ret = 0xad
; stamp_piece_writeback = 0xa8
; stop = 0x0
; tmp = 0x0
; undo_piece_state = 0x5c
; undo_piece_state_ret = 0x5f

; Memory image:
00: c810ff00 81000100 81000200 81000300 81000400 81000500 000000ff 000000ff
08: 81000800 81000900 81000a00 81000b00 81000c00 81000d00 81000e00 81000f00
10: 81001000 81001100 81001200 81001300 81001400 81001500 81001600 81001700
18: 81001800 81001900 81001a00 81001b00 000000ff 000000ff 40e00602 48900102
20: 49800702 81002100 81002200 81002300 84085f5c 81002500 81002600 81002700
28: 81002800 81002900 81002a00 81002b00 81002c00 84088760 08000400 84089688
30: 4800a1a0 8408ad97 006a0024 4800a5a0 8408ad97 00623739 8408d6c2 81003700
38: 4018ff1e 8408c1ae 4800a7a0 8408ad97 84085b58 e8000000 48e00200 00620049
40: 48e00200 00620052 48e00200 00620054 48e00100 00620055 48e00200 00620057
48: d8083f3d 48e00104 4800ff00 84089688 0062004e 80283733 4800a1a0 8408ad97
50: 00620033 80283724 48e00103 4018ff30 80280330 48e00105 4018ff25 80280525
58: 08000523 08000321 08000422 4018ff00 08002305 08002103 08002204 4018ff00
60: 08000265 0a000500 0a000000 08906565 48806665 4018ff00 48086674 48086674
68: 4808f074 4808f074 48082774 48087274 48083674 48083674 48086374 48086374
70: 48087174 48084774 48081774 48087474 4010ff00 0202057d 0800742a 4980f02a
78: 4800fc00 08807474 802a0079 08007428 4018ff87 4800fd65 48002c80 08008082
80: c0800000 0a007474 0a100000 48e00280 40e02580 006c007f 802a657e 4018ff00
88: 00620096 02022b96 02022996 02022796 02022596 0a002c2c 0a102b2b 0a002a2a
90: 0a102929 0a002828 0a102727 0a002626 0a102525 802a0089 4018ff00 4800259d
98: 48000e9f 0880039f 0880039f 4800f800 81009c00 80809c00 81009e00 80809e00
a0: 4018ff00 09809c9e 00629eaa 08009e00 4018ffad 08809c9e 4018ffa8 09c09c9e
a8: 08009fa9 08009e00 80209d00 80209f00 802a009c 4018ff00 480001b3 488008b3
b0: 480080ba 4800f6bb 0800ba00 81800000 006a00b6 d8087eb7 d8002300 488002b3
b8: 802abbb2 48e014b3 d8000d00 d8000a00 820abab1 48e009b3 0069b3af d8000d00
c0: d8000a00 4018ff00 8408e0d7 006abfc6 006ac0c6 4018ffd6 8100c600 8100c700
c8: 4800f6b6 480008cd 0800bfaa 0800c0ab 0820cdce 8080c600 8080c700 8408f1e1
d0: 0800cdd2 0800ced3 0800e100 0800e200 488002cd 802ab6ca 4018ff00 4800f600
d8: 4800ffbf 4800ffc0 480008dc 0820dcdd 8180bf00 8180c000 488002dc 802a00db
e0: 4018ff00 8100e100 8100e200 4800f000 0880aaaa 0890abab 006400ec 0880c6c6
e8: 0890c7c7 40e0f6b6 48900001 4018fff0 0880c6c6 0890c7c7 0890e1e1 0890e2e2
f0: 802a00e4 4018ff00
