Pass 1...

0 errors detected in pass 1

Pass 2...
1                       ; Prime Number Calculator (with hysteresis)
2                       ; Ryan Crosby 2018
3                       ;
4                       ; This version of the code is supposed to be as fast and messy as possible.
5                       ;
6                       
7                       ; Catch
8       00              	org	0x00
9       00 c810_ff00    	halt
10                      
11                      ; Config
12      01              	org	0x01
13      01 c810_ff80    arr_start	data	0x80
14                      
15                      ; Run
16      02              	org	0x02
17      02 0800_010a    run	st	arr_start, clrp_arrhead
18      03 8408_0f08    	jsr	clrp_ret, clrp	; Erase any existing primes in the primes array
19      04 0800_0110    	st	arr_start, sprimes_arrptr	
20      05 8408_2912    	jsr	sprimes_ret, sprimes	; Start finding primes
21      06 4018_ff00    run_ret	jmp	0
22                      
23                      ; Clear primes array function
24      07              clrp_tmp	skip	1	; Needed for indirect load
25      08 0800_010a    clrp	st	arr_start, clrp_arrhead	; Use clrp_ind1 as the array head pointer
26      09 4800_0007    clrp_loop	clr	clrp_tmp	; Prep tmp for load
27      0a 8080_0700    clrp_arrhead	add	clrp_tmp, 0	; Load value from array head
28      0b 0062_070f    	jeq	clrp_tmp, clrp_ret	; Stop as soon as we hit a 0x00 in the array
29      0c 0800_0a0d    	st	clrp_arrhead, clrp_ind
30      0d 4800_0000    clrp_ind	clr	0	; Current array head is not 0x00, so clear it
31      0e 802a_0a09    	incjne	clrp_arrhead, clrp_loop	; Increment array head pointer and loop
32      0f 4018_ff00    clrp_ret	jmp	0	; Return
33                      
34                      ; Prime Search Function
35                      ;
36                      ; Searches for prime numbers, starting at n.
37                      ; When primes are found, they are saved to an array, and printed to console.
38                      ;
39                      ; In order to save memory and reduce copying, we use the variables on isprime as state storage rather than tracking them at the start of this function.
40                      ;
41      10              	org	0x10
42      10              sprimes_arrptr	skip	1	; Pointer to the location of the primes array
43      11              sprimes_arrhead	skip	1	; Pointer to the head of the primes array
48      12 0800_1011    sprimes	st	sprimes_arrptr, sprimes_arrhead
49      13 0800_1114    	st	sprimes_arrhead, sprimes_stind1	; Prep indirect store into [sprimes_arrptr]
50      14 4800_0200    sprimes_stind1	st	#2, 0	; Write 2 to the start of the primes array.
51      15 4880_0111    	inc	sprimes_arrhead	; Increment the head by 1
52                      
53      16 d800_3200    	outc	#0x32	; Print 2 to console.
54      17 d800_2c00    	outc	#0x2C	; Print comma
55      18 d800_2000    	outc	#0x20	; Print space
58      19 4800_032a    	st	#3, dechlp_0
59      1a 4800_002b    	clr	dechlp_1
60      1b 4800_002c    	clr	dechlp_2
61                      
63      1c 4800_0345    	st	#3, isprime_n	; Start the prime search from three, since we've already found 2.
64      1d 0800_1046    	st	sprimes_arrptr, isprime_arrptr	; The array pointer never changes in the loop, so we only need to copy it once.
67      1e 8408_614b    sprimes_start	jsr	isprime_ret, isprime	; Check if the current isprime_n is prime.
68      1f 006a_4726    	jne	isprime_res, sprimes_next	; Restart the loop if we didn't find a prime.
71      20 0800_1121    	st	sprimes_arrhead, sprimes_stind2	; Prime store instruction with pointer
72      21 0800_4500    sprimes_stind2	st	isprime_n, 0	; Write prime to array
73      22 4880_0111    	inc	sprimes_arrhead	; Increment array head
74      23 8408_4437    	jsr	dechlp_print_ret, dechlp_print	; Print prime to console
75      24 d800_2c00    	outc	#0x2C	; Print comma
76      25 d800_2000    	outc	#0x20	; Print space
77                      
78      26 4880_0245    sprimes_next	addto	#2, isprime_n	; Increment the prime candidate. Jump by 2 to skip even numbers that can't be prime.
79      27 8408_302d    	jsr	dechlp_inc2_ret, dechlp_inc2	; Increment decimal value of prime candidate by 2.
80      28 006a_111e    	jne	sprimes_arrhead, sprimes_start	; Jump back to start of loop. Don't jump if we're out of memory for the array.
81      29 4018_ff00    sprimes_ret	jmp	0	; Return to the calling function.
82                      
83                      ; Track decimal representation of the prime for fast printing
84                      ;
85      2a              dechlp_0	skip	1	; Ones digit
86      2b              dechlp_1	skip	1	; Tens digit
87      2c              dechlp_2	skip	1	; Hundreds digit
88                      
89                      ; Increment by 2 funciton
90      2d 48e0_082a    dechlp_inc2	rsbto	#8, dechlp_0	; Increment the current decimal value by 2
91      2e 0069_2a31    	jge	dechlp_0, dechlp_overflow_0	; If (([0] + 2) - 10) < 0, we have overflowed the ones digit.
92      2f 4880_0a2a    	addto	#10, dechlp_0	; No overflow on ones yet, add 10 on to accomplish overall [0] += 2
93      30 4018_ff00    dechlp_inc2_ret	jmp	0	; Return subroutine
94      31 48e0_092b    dechlp_overflow_0	rsbto	#9, dechlp_1
95      32 0069_2b35    	jge	dechlp_1, dechlp_overflow_1	; IF (([1] + 1) - 10) < 0, we have overflowed the tens digit.
96      33 4880_0a2b    	addto	#10, dechlp_1	; No overflow on tens yet, add 10 on to accomplish overall [1] += 1
97      34 4018_ff30    	jmp	dechlp_inc2_ret	; Return
98      35 4880_012c    dechlp_overflow_1	inc	dechlp_2	; Increment the hundreds digit and return. Don't bother to overflow check hundreds digit.
99      36 4018_ff30    	jmp	dechlp_inc2_ret	; Return
100                     
101                     ; Print function
102     37 020a_2c3b    dechlp_print	je	dechlp_2, dechlp_print_1	; Skip printing leading zero
103     38 4880_302c    	addto	#0x30, dechlp_2	; Convert to ASCII character
104     39 9800_2c00    	outc	dechlp_2	; Print hundreds digit
105     3a 48e0_302c    	rsbto	#0x30, dechlp_2	; Revert ASCII conversion
106     3b 006a_2b3e    dechlp_print_1	jne	dechlp_1, dechlp_print_1_a
107     3c 006a_2c3e    	jne	dechlp_2, dechlp_print_1_a
108     3d 4018_ff41    	jmp	dechlp_print_0	; Skip printing leading zero if this and previous digit was zero
109     3e 4880_302b    dechlp_print_1_a	addto	#0x30, dechlp_1
110     3f 9800_2b00    	outc	dechlp_1
111     40 48e0_302b    	rsbto	#0x30, dechlp_1
112     41 4880_302a    dechlp_print_0	addto	#0x30, dechlp_0
113     42 9800_2a00    	outc	dechlp_0
114     43 48e0_302a    	rsbto	#0x30, dechlp_0
115     44 4018_ff00    dechlp_print_ret	jmp	0
116                     
118                     ; Fast IsPrime Function
119                     ;
120                     ; Determines if n is prime using trial division by the previous prime numbers.
121                     ; Returns 0 if prime, or the factors of n if not.
122                     ;
123                     ; For speed: Does not handle n = 2. 2 is prime, but the cost of doing a special case check for it is too great.
124                     ;
125     45              isprime_n	skip	1	; The number to check for primeness
126     46              isprime_arrptr	skip	1	; The address of the array of previous primes
127     47              isprime_res	skip	1	; The result. 0 if n was prime, or smaller factor if not prime.
128     48              isprime_resb	skip	1	; Second result. 0 if n was prime, or larger factor if prime.
129     49              isprime_arri	skip	1	; The current test divisor index into arr
130     4a              isprime_div	skip	1	; The value of the current divisor
131     4b 0202_454f    isprime	jo	isprime_n, isprime_start	; Check if the number is odd. If so, do division search. Technically we don't need to do this, but it's only one instruction.
132     4c 4800_0247    	st	#0x02, isprime_res	; We have an even number, it is divisible by 2
133     4d 0a00_4548    	lsrto	isprime_n, isprime_resb	; The larger factor is just n / 2, or n >> 1.
134     4e 4018_ff61    	jmp	isprime_ret	; Return.
135     4f 4800_0047    isprime_start	clr	isprime_res	; Clear the result, so in the case of a prime we can return directly.
136     50 4800_0048    	clr	isprime_resb	; Clear b result as well.
137     51 4800_ff62    	st	#0xFF, div_quotient	; We need this to start from largest number for sqrt check below.
138     52 4800_0149    	st	#1, isprime_arri	; Start from index 1, since index 0 is preloaded with 2. We already know n is not even, so no point dividing by 2.
139                     
141     53 0800_4656    isprime_loop	st	isprime_arrptr, isprime_ld	; Put pointer to current divisor into add below.
142     54 0880_4956    	addto	isprime_arri, isprime_ld	; Add divisor index offset
143     55 4800_004a    	clr	isprime_div	; Prepare to do an indirect load with add. For this, destination must be 0.
144     56 8080_4a00    isprime_ld	add	isprime_div, 0	; Load current divisor from arri into div
145     57 0062_4a61    	jeq	isprime_div, isprime_ret	; Return if the divisor is 0. If it's 0, we have reached the end of the divisor array (zero terminated)
152     58 08e0_4a62    	rsbto	isprime_div, div_quotient
153     59 0066_6261    	jls	div_quotient, isprime_ret	; Return.
154                     
155     5a 4880_0149    	inc	isprime_arri	; Incrememnt array index
158     5b 0800_4564    	st	isprime_n, div_dividend	; Do division
159     5c 0800_4a65    	st	isprime_div, div_divisor
160     5d 8408_7367    	jsr	div_ret, div	; Do division
161     5e 006a_6353    	jne	div_remainder, isprime_loop	; Check if remainder was 0. If it wasn't, we might still have a prime. Check next divisor.
162                     
164     5f 0800_4a47    	st	isprime_div, isprime_res	; Remainder was 0, not a prime. Store smaller factor in res.
165     60 0800_6248    	st	div_quotient, isprime_resb	; Store larger factor in resb
166     61 4018_ff00    isprime_ret	jmp	0	; Return.
167                     
168                     ; Divide
169                     
170     62              div_quotient	skip	1
171     63              div_remainder	skip	1
172     64              div_dividend	skip	1
173     65              div_divisor	skip	1
174     66              div_count	skip	1
175     67 4800_0063    div	clr	div_remainder
176     68 4800_f866    	st	#-8, div_count
177     69 0880_6464    div_lop	lsl	div_dividend
178     6a 0890_6363    	rol	div_remainder
179     6b 08e0_6563    	rsbto	div_divisor, div_remainder
180     6c 0064_0070    	jcc	div_toomuch
181     6d 08a0_6262    	lslo	div_quotient
182     6e 802a_6669    	incjne	div_count, div_lop
183     6f 4018_ff73    	jmp	div_ret
184     70 0880_6563    div_toomuch	addto	div_divisor, div_remainder
185     71 0880_6262    	lsl	div_quotient
186     72 802a_6669    	incjne	div_count, div_lop
187     73 4018_ff00    div_ret	jmp	0

0 errors detected in pass 2

Symbol table:
arr_start = 0x1
clrp = 0x8
clrp_arrhead = 0xa
clrp_ind = 0xd
clrp_loop = 0x9
clrp_ret = 0xf
clrp_tmp = 0x7
dechlp_0 = 0x2a
dechlp_1 = 0x2b
dechlp_2 = 0x2c
dechlp_inc2 = 0x2d
dechlp_inc2_ret = 0x30
dechlp_overflow_0 = 0x31
dechlp_overflow_1 = 0x35
dechlp_print = 0x37
dechlp_print_0 = 0x41
dechlp_print_1 = 0x3b
dechlp_print_1_a = 0x3e
dechlp_print_ret = 0x44
div = 0x67
div_count = 0x66
div_dividend = 0x64
div_divisor = 0x65
div_lop = 0x69
div_quotient = 0x62
div_remainder = 0x63
div_ret = 0x73
div_toomuch = 0x70
isprime = 0x4b
isprime_arri = 0x49
isprime_arrptr = 0x46
isprime_div = 0x4a
isprime_ld = 0x56
isprime_loop = 0x53
isprime_n = 0x45
isprime_res = 0x47
isprime_resb = 0x48
isprime_ret = 0x61
isprime_start = 0x4f
run = 0x2
run_ret = 0x6
sprimes = 0x12
sprimes_arrhead = 0x11
sprimes_arrptr = 0x10
sprimes_next = 0x26
sprimes_ret = 0x29
sprimes_start = 0x1e
sprimes_stind1 = 0x14
sprimes_stind2 = 0x21

Memory image:
00: c810ff00 c810ff80 0800010a 84080f08 08000110 84082912 4018ff00
08: 0800010a 48000007 80800700 0062070f 08000a0d 48000000 802a0a09 4018ff00
12: 08001011 08001114 48000200 48800111 d8003200 d8002c00
18: d8002000 4800032a 4800002b 4800002c 48000345 08001046 8408614b 006a4726
20: 08001121 08004500 48800111 84084437 d8002c00 d8002000 48800245 8408302d
28: 006a111e 4018ff00
2d: 48e0082a 00692a31 48800a2a
30: 4018ff00 48e0092b 00692b35 48800a2b 4018ff30 4880012c 4018ff30 020a2c3b
38: 4880302c 98002c00 48e0302c 006a2b3e 006a2c3e 4018ff41 4880302b 98002b00
40: 48e0302b 4880302a 98002a00 48e0302a 4018ff00
4b: 0202454f 48000247 0a004548 4018ff61 48000047
50: 48000048 4800ff62 48000149 08004656 08804956 4800004a 80804a00 00624a61
58: 08e04a62 00666261 48800149 08004564 08004a65 84087367 006a6353 08004a47
60: 08006248 4018ff00
67: 48000063
68: 4800f866 08806464 08906363 08e06563 00640070 08a06262 802a6669 4018ff73
70: 08806563 08806262 802a6669 4018ff00
