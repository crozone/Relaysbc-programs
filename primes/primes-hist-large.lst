Pass 1...

0 errors detected in pass 1

Pass 2...
1                       ; Prime Number Calculator (with hysteresis)
2                       ; Ryan Crosby 2018
3                       
4                       ; Run
5       05              	org 0x05
6       05 4800_0210    run	st	#0x02, sprimes_n	; Start prime search from 2
7       06 4800_a011    	st	#0xA0, sprimes_arrptr	; Write results into array starting at 0x80
8       07 8408_2213    	jsr	sprimes_ret, sprimes
9       08 c810_ff00    	halt
10                      
11                      ; Prime Search Function
12                      ;
13                      ; Searches for prime numbers, starting at n.
14                      ; When primes are found, they are saved to an array, and printed to console.
15                      ;
16      10              	org	0x10
17      10 c810_ff00    sprimes_n	data	0x00
18      11 c810_ff00    sprimes_arrptr	data	0x00
19      12 c810_ff00    sprimes_arrlen	data	0x00
20      13 4800_0012    sprimes	clr	sprimes_arrlen
21      14 0800_1124    	st	sprimes_arrptr, isprime_arrptr	; This never changes, so we don't need to copy it inside the loop.
22      15 0800_1023    sprimes_start	st	sprimes_n, isprime_n
23      16 0800_1225    	st	sprimes_arrlen, isprime_arrlen
24      17 8408_4d2b    	jsr	isprime_ret, isprime
25      18 006a_2621    	jne	isprime_res, sprimes_next
27      19 0800_111b    	st	sprimes_arrptr, sprimes_ind	; Prime store instruction with pointer
28      1a 0880_121b    	addto	sprimes_arrlen, sprimes_ind	; Add extra offset to pointer
29      1b 0800_1000    sprimes_ind	st	sprimes_n, 0	; Write prime to array
30      1c 4880_0112    	inc	sprimes_arrlen	; arrlen++;
31      1d 0800_1068    	st	sprimes_n, print_n
32      1e 8408_7f6a    	jsr	print_ret, print	; Print number
33      1f d800_2c00    	outc	#0x2C	; Print comma
34      20 d800_2000    	outc	#0x20	; Print space
35      21 802a_1015    sprimes_next	incjne	sprimes_n, sprimes_start
36      22 4018_ff00    sprimes_ret	jmp	0
38                      ; IsPrime Function
39                      ;
40                      ; Determines if n is prime using trial division by the previous prime numbers.
41                      ; Returns 0 if prime, or the factors of n if not.
42                      ;
43      23              isprime_n	skip	1	; The number to check for primeness
44      24              isprime_arrptr	skip	1	; The address of the array of previous primes
45      25              isprime_arrlen	skip	1	; The length of the previous primes array
46      26              isprime_res	skip	1	; The result. 0 if n was prime, or smaller factor if not prime.
47      27              isprime_resb	skip	1	; Second result. 0 if n was prime, or larger factor if prime.
48      28              isprime_divi	skip	1	; The current test divisor index into arr
49      29              isprime_div	skip	1	; The value of the current divisor
50      2a              isprime_sqrt	skip	1	; The square root of n
51      2b 48e0_0223    isprime	rsbto	#0x02, isprime_n	; Check if the number is 2 or less, if so, return prime.
52      2c 006b_2331    	jgt	isprime_n, isprime_gt2
53      2d 4880_0223    	addto	#0x02, isprime_n	; Revert rsbto
54      2e 4800_0026    	clr	isprime_res
55      2f 4800_0027    	clr	isprime_resb
56      30 4018_ff4d    	jmp	isprime_ret		; Return prime.
57      31 4880_0223    isprime_gt2	addto	#0x02, isprime_n	; Revert rsbto
58      32 0202_2336    	jo	isprime_n, isprime_dodiv	; Check if the number is odd. If so, do division search.
59      33 4800_0226    	st	#0x02, isprime_res	; We have an even number, it is divisible by 2
60      34 0a00_2327    	lsrto	isprime_n, isprime_resb	; The larger factor is just n / 2, or n >> 1.
61      35 4018_ff4d    	jmp	isprime_ret
62      36 4800_0026    isprime_dodiv	clr	isprime_res	; Clear the result, so in the case of a prime we can return directly.
63      37 4800_0027    	clr	isprime_resb	; Clear b result as well.
64      38 4800_0128    	st	#1, isprime_divi	; Start from index 1, since index 0 is preloaded with 2 and we have already checked for even-ness.
65      39 0800_234e    	st	isprime_n, sqrt_n	; Find the square root of n. We never have to divide by more than this.
66      3a 8408_5550    	jsr	sqrt_ret, sqrt
67      3b 0800_4f2a    	st	sqrt_res, isprime_sqrt
68      3c 08e0_2528    isprime_loop	rsbto	isprime_arrlen, isprime_divi	; Check if our index is above arrlen, and if so return prime.
69      3d 0069_284d    	jge	isprime_divi, isprime_ret	; If isprime_divi >= isprime_arrlen, jump to return
70      3e 0880_2528    	addto	isprime_arrlen, isprime_divi	; Revert rsbto
71      3f 0800_2442    	st	isprime_arrptr, isprime_ld	; Put pointer to current divisor into add below.
72      40 0880_2842    	addto	isprime_divi, isprime_ld	; Add divisor index offset
73      41 4800_0029    	clr	isprime_div
74      42 8080_2900    isprime_ld	add	isprime_div, 0	; Load current divisor into div
75      43 4880_0128    	inc	isprime_divi	; Incrememnt array index
76      44 08e0_2a29    	rsbto	isprime_sqrt, isprime_div	; Check if the current divisor is greater than sqrt(n), and if so return prime.
77      45 006e_294d    	jhi	isprime_div, isprime_ret	; If isprime_div > isprime_sqrt, jump to return.
78      46 0880_2a29    	addto	isprime_sqrt, isprime_div	; Revert rsbto
79      47 0800_2358    	st	isprime_n, div_dividend	; Do division
80      48 0800_2959    	st	isprime_div, div_divisor
81      49 8408_675b    	jsr	div_ret, div
82      4a 006a_573c    	jne	div_remainder, isprime_loop	; Check if remainder was 0. If it wasn't, we might still have a prime. Check next divisor.
83      4b 0800_2926    	st	isprime_div, isprime_res	; Remainder was 0, not a prime. Store smaller factor in res.
84      4c 0800_5627    	st	div_quotient, isprime_resb	; Store larger factor in resb
85      4d 4018_ff00    isprime_ret	jmp	0	; Return.
86                      
87                      ; Integer square root
88      4e              sqrt_n	skip	1	; Find square root of this
89      4f              sqrt_res	skip	1	; Result ends up here
90                      
91      50 4800_ff4f    sqrt	st	#0xFF, sqrt_res
92      51 4880_024f    sqrt_1	addto	#2, sqrt_res
93      52 08e0_4f4e    	rsbto	sqrt_res, sqrt_n
94      53 006c_0051    	jcs	sqrt_1
95      54 0a00_4f4f    	lsr	sqrt_res
96      55 4018_ff00    sqrt_ret	jmp	0
97                      
98                      ; Divide
99                      
100     56              div_quotient	skip	1
101     57              div_remainder	skip	1
102     58              div_dividend	skip	1
103     59              div_divisor	skip	1
104     5a              div_count	skip	1
105     5b 4800_0057    div	clr	div_remainder
106     5c 4800_f85a    	st	#-8, div_count
107     5d 0880_5858    div_lop	lsl	div_dividend
108     5e 0890_5757    	rol	div_remainder
109     5f 08e0_5957    	rsbto	div_divisor, div_remainder
110     60 0064_0064    	jcc	div_toomuch
111     61 08a0_5656    	lslo	div_quotient
112     62 802a_5a5d    	incjne	div_count, div_lop
113     63 4018_ff67    	jmp	div_ret
114     64 0880_5957    div_toomuch	addto	div_divisor, div_remainder
115     65 0880_5656    	lsl	div_quotient
116     66 802a_5a5d    	incjne	div_count, div_lop
117     67 4018_ff00    div_ret	jmp	0
118                     
119                     ; Print function
120                     ; Print hex/binary number to console as decimal string
121                     
122     68              print_n	skip	1	; Hex/binary number to print
123     69              print_tmp	skip	1	; Scratch space for ASCII calculation
124     6a 0800_6880    print	st	print_n, ddabble_n
125     6b 8408_9c85    	jsr	ddabble_ret, ddabble	; Run Double Dabble algorithm on n
126     6c 0062_8271    print_2	jeq	ddabble_2, print_1	; Don't print leading zero
127     6d 0800_8269    	st	ddabble_2, print_tmp	; Hundreds digit is in lower nubble of 2
128     6e 4880_3069    	addto	#0x30, print_tmp	; Convert into ASCII by adding '0'
129     6f 9800_6900    	outc	print_tmp	; Print hundreds digit
130     70 4018_ff71    	jmp	print_1
131     71 0800_8169    print_1	st	ddabble_01, print_tmp	; Tens digit is in upper nibble of 01
132     72 0a00_6969    	lsr	print_tmp	; Shift tens digit into lower nibble (also removes ones digit)
133     73 0a00_6969    	lsr	print_tmp
134     74 0a00_6969    	lsr	print_tmp
135     75 0a00_6969    	lsr	print_tmp
136     76 006a_6979    	jne	print_tmp, print_1a
137     77 006a_8279    	jne	ddabble_2, print_1a
138     78 4018_ff7b    	jmp	print_0	; Skip leading zero if hundreds was also a zero too.
139     79 4880_3069    print_1a	addto	#0x30, print_tmp	; Convert into ASCII by adding '0'
140     7a 9800_6900    	outc	print_tmp	; Print tens digit
141     7b 0800_8169    print_0	st	ddabble_01, print_tmp     ; Ones digit is in lower nibble of 01
142     7c 4980_0f69    	andto	#0x0F, print_tmp	; Mask out 10s digit
143     7d 4880_3069    	addto	#0x30, print_tmp	; Convert into ASCII by adding '0'
144     7e 9800_6900    	outc	print_tmp	; Print ones digit
145     7f 4018_ff00    print_ret	jmp	0
146                     
147                     ; Convert hex number to decimal by Double Dabble algorithm
148                     ;
149     80              ddabble_n	skip	1	; The binary number to convert. This argument is destroyed.
150     81              ddabble_01	skip	1	; The first decimal digit (ones digit), lower nibble, and the second decimal digit (tens digit), upper nibble.
151     82              ddabble_2	skip	1	; The third decimal digit (hundreds digit), lower nibble.
152     83              ddabble_i	skip	1	; Interation counter
153     84              ddabble_tmp	skip	1	; Scratch space
154     85 4800_0081    ddabble	clr	ddabble_01	; Subroutine start.
155     86 4800_0082    	clr	ddabble_2
156     87 4800_f883    	st	#-8, ddabble_i	; Run the loop 8 times for an 8 bit input.
157     88 0062_828d    ddabble_c2	jeq	ddabble_2, ddabble_c1	; Optimisation. If digit 2 is zero, don't need to check it.
158     89 0800_8284    	st	ddabble_2, ddabble_tmp
159     8a 48e0_0484    	rsbto	#0x04, ddabble_tmp
160     8b 0066_848d    	jls	ddabble_tmp, ddabble_c1
161     8c 4880_0382    	addto	#0x03, ddabble_2
162     8d 0062_8198    ddabble_c1	jeq	ddabble_01, ddabble_r	; Optimisation. If digits 0 and 1 are both zero, don't need to check them.
163     8e 0800_8184    	st	ddabble_01, ddabble_tmp
164     8f 4980_f084    	andto	#0xF0, ddabble_tmp	; Mask off upper nibble (digit 1)
165     90 48e0_4084    	rsbto	#0x40, ddabble_tmp
166     91 0066_8493    	jls	ddabble_tmp, ddabble_c0
167     92 4880_3081    	addto	#0x30, ddabble_01
168     93 0800_8184    ddabble_c0	st	ddabble_01, ddabble_tmp
169     94 4980_0f84    	andto	#0x0F, ddabble_tmp	; Mask off lower nibble (digit 0)
170     95 48e0_0484    	rsbto	#0x04, ddabble_tmp
171     96 0066_8498    	jls	ddabble_tmp, ddabble_r
172     97 4880_0381    	addto	#0x03, ddabble_01
173     98 0880_8080    ddabble_r	lsl	ddabble_n	; Left rotate all data by 1 bit
174     99 0890_8181    	rol	ddabble_01
175     9a 0890_8282    	rol	ddabble_2
176     9b 802a_8388    	incjne	ddabble_i, ddabble_c2	; Loop.
177     9c 4018_ff00    ddabble_ret	jmp	0	; Return subroutine.

0 errors detected in pass 2

Symbol table:
ddabble = 0x85
ddabble_01 = 0x81
ddabble_2 = 0x82
ddabble_c0 = 0x93
ddabble_c1 = 0x8d
ddabble_c2 = 0x88
ddabble_i = 0x83
ddabble_n = 0x80
ddabble_r = 0x98
ddabble_ret = 0x9c
ddabble_tmp = 0x84
div = 0x5b
div_count = 0x5a
div_dividend = 0x58
div_divisor = 0x59
div_lop = 0x5d
div_quotient = 0x56
div_remainder = 0x57
div_ret = 0x67
div_toomuch = 0x64
isprime = 0x2b
isprime_arrlen = 0x25
isprime_arrptr = 0x24
isprime_div = 0x29
isprime_divi = 0x28
isprime_dodiv = 0x36
isprime_gt2 = 0x31
isprime_ld = 0x42
isprime_loop = 0x3c
isprime_n = 0x23
isprime_res = 0x26
isprime_resb = 0x27
isprime_ret = 0x4d
isprime_sqrt = 0x2a
print = 0x6a
print_0 = 0x7b
print_1 = 0x71
print_1a = 0x79
print_2 = 0x6c
print_n = 0x68
print_ret = 0x7f
print_tmp = 0x69
run = 0x5
sprimes = 0x13
sprimes_arrlen = 0x12
sprimes_arrptr = 0x11
sprimes_ind = 0x1b
sprimes_n = 0x10
sprimes_next = 0x21
sprimes_ret = 0x22
sprimes_start = 0x15
sqrt = 0x50
sqrt_1 = 0x51
sqrt_n = 0x4e
sqrt_res = 0x4f
sqrt_ret = 0x55

Memory image:
05: 48000210 4800a011 84082213
08: c810ff00
10: c810ff00 c810ff00 c810ff00 48000012 08001124 08001023 08001225 84084d2b
18: 006a2621 0800111b 0880121b 08001000 48800112 08001068 84087f6a d8002c00
20: d8002000 802a1015 4018ff00
2b: 48e00223 006b2331 48800223 48000026 48000027
30: 4018ff4d 48800223 02022336 48000226 0a002327 4018ff4d 48000026 48000027
38: 48000128 0800234e 84085550 08004f2a 08e02528 0069284d 08802528 08002442
40: 08802842 48000029 80802900 48800128 08e02a29 006e294d 08802a29 08002358
48: 08002959 8408675b 006a573c 08002926 08005627 4018ff00
50: 4800ff4f 4880024f 08e04f4e 006c0051 0a004f4f 4018ff00
5b: 48000057 4800f85a 08805858 08905757 08e05957
60: 00640064 08a05656 802a5a5d 4018ff67 08805957 08805656 802a5a5d 4018ff00
6a: 08006880 84089c85 00628271 08008269 48803069 98006900
70: 4018ff71 08008169 0a006969 0a006969 0a006969 0a006969 006a6979 006a8279
78: 4018ff7b 48803069 98006900 08008169 49800f69 48803069 98006900 4018ff00
85: 48000081 48000082 4800f883
88: 0062828d 08008284 48e00484 0066848d 48800382 00628198 08008184 4980f084
90: 48e04084 00668493 48803081 08008184 49800f84 48e00484 00668498 48800381
98: 08808080 08908181 08908282 802a8388 4018ff00
